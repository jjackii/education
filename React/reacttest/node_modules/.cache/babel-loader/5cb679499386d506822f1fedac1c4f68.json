{"ast":null,"code":"import React, { forwardRef, useContext, useState, useMemo, useLayoutEffect, useEffect, useRef, useReducer, useCallback, memo } from 'react';\nimport ReactDOM, { unstable_batchedUpdates, createPortal } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { useTransition } from 'react-transition-state';\nconst menuContainerClass = 'szh-menu-container';\nconst menuClass = 'szh-menu';\nconst menuButtonClass = 'szh-menu-button';\nconst menuArrowClass = 'arrow';\nconst menuItemClass = 'item';\nconst menuDividerClass = 'divider';\nconst menuHeaderClass = 'header';\nconst menuGroupClass = 'group';\nconst subMenuClass = 'submenu';\nconst radioGroupClass = 'radio-group';\nconst initialHoverIndex = -1;\nconst HoverIndexContext = /*#__PURE__*/React.createContext(initialHoverIndex);\nconst MenuListItemContext = /*#__PURE__*/React.createContext({});\nconst MenuListContext = /*#__PURE__*/React.createContext({});\nconst EventHandlersContext = /*#__PURE__*/React.createContext({});\nconst RadioGroupContext = /*#__PURE__*/React.createContext({});\nconst SettingsContext = /*#__PURE__*/React.createContext({});\nconst ItemSettingsContext = /*#__PURE__*/React.createContext({});\nconst Keys = Object.freeze({\n  'ENTER': 'Enter',\n  'ESC': 'Escape',\n  'SPACE': ' ',\n  'HOME': 'Home',\n  'END': 'End',\n  'LEFT': 'ArrowLeft',\n  'RIGHT': 'ArrowRight',\n  'UP': 'ArrowUp',\n  'DOWN': 'ArrowDown'\n});\nconst HoverIndexActionTypes = Object.freeze({\n  'RESET': 'HOVER_INDEX_RESET',\n  'SET': 'HOVER_INDEX_SET',\n  'UNSET': 'HOVER_INDEX_UNSET',\n  'INCREASE': 'HOVER_INDEX_INCREASE',\n  'DECREASE': 'HOVER_INDEX_DECREASE',\n  'FIRST': 'HOVER_INDEX_FIRST',\n  'LAST': 'HOVER_INDEX_LAST'\n});\nconst SubmenuActionTypes = Object.freeze({\n  'OPEN': 'SUBMENU_OPEN',\n  'CLOSE': 'SUBMENU_CLOSE'\n});\nconst CloseReason = Object.freeze({\n  'CLICK': 'click',\n  'CANCEL': 'cancel',\n  'BLUR': 'blur',\n  'SCROLL': 'scroll'\n});\nconst FocusPositions = Object.freeze({\n  'INITIAL': 'initial',\n  'FIRST': 'first',\n  'LAST': 'last'\n});\nconst MenuStateMap = Object.freeze({\n  entering: 'opening',\n  entered: 'open',\n  exiting: 'closing',\n  exited: 'closed'\n});\n\nconst batchedUpdates = unstable_batchedUpdates || (callback => callback());\n\nconst defineName = (component, name) => name ? Object.defineProperty(component, '_szhsinMenu', {\n  value: name,\n  writable: false\n}) : component;\n\nconst getName = component => component && component['_szhsinMenu'];\n\nconst applyHOC = HOC => (...args) => defineName(HOC(...args), getName(args[0]));\n\nconst applyStatics = sourceComponent => wrappedComponent => defineName(wrappedComponent, getName(sourceComponent));\n\nconst safeCall = (fn, ...args) => typeof fn === 'function' ? fn(...args) : fn;\n\nconst attachHandlerProps = (handlers, props) => {\n  if (!props) return handlers;\n  const result = {};\n\n  for (const handlerName of Object.keys(handlers)) {\n    const handler = handlers[handlerName];\n    const propHandler = props[handlerName];\n    let attachedHandler;\n\n    if (typeof propHandler === 'function') {\n      attachedHandler = e => {\n        propHandler(e);\n        handler(e);\n      };\n    } else {\n      attachedHandler = handler;\n    }\n\n    result[handlerName] = attachedHandler;\n  }\n\n  return result;\n};\n\nconst parsePadding = paddingStr => {\n  if (typeof paddingStr !== 'string') return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  const padding = paddingStr.trim().split(/\\s+/, 4).map(parseFloat);\n  const top = !isNaN(padding[0]) ? padding[0] : 0;\n  const right = !isNaN(padding[1]) ? padding[1] : top;\n  return {\n    top,\n    right,\n    bottom: !isNaN(padding[2]) ? padding[2] : top,\n    left: !isNaN(padding[3]) ? padding[3] : right\n  };\n};\n\nconst getScrollAncestor = node => {\n  while (node && node !== document.body) {\n    const {\n      overflow,\n      overflowX,\n      overflowY\n    } = getComputedStyle(node);\n    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) return node;\n    node = node.parentNode;\n  }\n\n  return window;\n};\n\nconst values = Object.values || (obj => Object.keys(obj).map(key => obj[key]));\n\nconst floatEqual = (a, b, diff = 0.0001) => Math.abs(a - b) < diff;\n\nconst isProd = process.env.NODE_ENV === 'production';\n\nconst isMenuOpen = state => state === 'open' || state === 'opening';\n\nconst getTransition = (transition, name) => Boolean(transition && transition[name]) || transition === true;\n\nconst validateChildren = (parent, child, permitted) => {\n  if (!child) return false;\n\n  if (!permitted.includes(getName(child.type))) {\n    !isProd && console.warn(`[react-menu] ${child.type || child} is ignored.\\n`, `The permitted children inside a ${parent} are ${permitted.join(', ')}.`, 'If you create HOC of these components, you can use the applyHOC or applyStatics helper, see more at: https://szhsin.github.io/react-menu/docs#utils-apply-hoc');\n    return false;\n  }\n\n  return true;\n};\n\nconst cloneChildren = (children, startIndex = 0) => {\n  let index = startIndex;\n  let descendOverflow = false;\n  const permittedChildren = ['MenuDivider', 'MenuGroup', 'MenuHeader', 'MenuItem', 'FocusableItem', 'MenuRadioGroup', 'SubMenu'];\n  const items = React.Children.map(children, child => {\n    if (!validateChildren('Menu or SubMenu', child, permittedChildren)) return null;\n\n    switch (getName(child.type)) {\n      case 'MenuDivider':\n      case 'MenuHeader':\n        return child;\n\n      case 'MenuRadioGroup':\n        {\n          const permittedChildren = ['MenuItem'];\n          const props = {\n            type: 'radio'\n          };\n          const radioItems = React.Children.map(child.props.children, radioChild => {\n            if (!validateChildren('MenuRadioGroup', radioChild, permittedChildren)) return null;\n            return radioChild.props.disabled ? /*#__PURE__*/React.cloneElement(radioChild, props) : /*#__PURE__*/React.cloneElement(radioChild, { ...props,\n              index: index++\n            });\n          });\n          return /*#__PURE__*/React.cloneElement(child, {\n            children: radioItems\n          });\n        }\n\n      case 'MenuGroup':\n        {\n          const {\n            items,\n            endIndex,\n            descendOverflow: descOverflow\n          } = cloneChildren(child.props.children, index);\n          index = endIndex;\n          const takeOverflow = Boolean(child.props.takeOverflow);\n          if (!isProd && (descendOverflow === descOverflow ? descOverflow : takeOverflow)) throw new Error('[react-menu] Only one MenuGroup in a menu is allowed to have takeOverflow prop.');\n          descendOverflow = descendOverflow || descOverflow || takeOverflow;\n          return /*#__PURE__*/React.cloneElement(child, {\n            children: items\n          });\n        }\n\n      default:\n        return child.props.disabled ? child : /*#__PURE__*/React.cloneElement(child, {\n          index: index++\n        });\n    }\n  });\n  return {\n    items,\n    endIndex: index,\n    descendOverflow\n  };\n};\n\nconst stylePropTypes = name => ({\n  [name ? `${name}ClassName` : 'className']: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  [name ? `${name}Styles` : 'styles']: PropTypes.oneOfType([PropTypes.object, PropTypes.func])\n});\n\nconst sharedMenuPropTypes = {\n  className: PropTypes.string,\n  ...stylePropTypes('menu'),\n  ...stylePropTypes('arrow'),\n  arrow: PropTypes.bool,\n  offsetX: PropTypes.number,\n  offsetY: PropTypes.number,\n  align: PropTypes.oneOf(['start', 'center', 'end']),\n  direction: PropTypes.oneOf(['left', 'right', 'top', 'bottom']),\n  position: PropTypes.oneOf(['auto', 'anchor', 'initial']),\n  overflow: PropTypes.oneOf(['auto', 'visible', 'hidden']),\n  children: PropTypes.node.isRequired\n};\nconst menuPropTypesBase = { ...sharedMenuPropTypes,\n  containerProps: PropTypes.object,\n  initialMounted: PropTypes.bool,\n  unmountOnClose: PropTypes.bool,\n  transition: PropTypes.oneOfType([PropTypes.bool, PropTypes.exact({\n    open: PropTypes.bool,\n    close: PropTypes.bool,\n    item: PropTypes.bool\n  })]),\n  transitionTimeout: PropTypes.number,\n  boundingBoxRef: PropTypes.object,\n  boundingBoxPadding: PropTypes.string,\n  reposition: PropTypes.oneOf(['auto', 'initial']),\n  repositionFlag: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  viewScroll: PropTypes.oneOf(['auto', 'close', 'initial']),\n  submenuOpenDelay: PropTypes.number,\n  submenuCloseDelay: PropTypes.number,\n  portal: PropTypes.bool,\n  theming: PropTypes.string,\n  onItemClick: PropTypes.func\n};\nconst sharedMenuDefaultProp = {\n  offsetX: 0,\n  offsetY: 0,\n  align: 'start',\n  direction: 'bottom',\n  position: 'auto',\n  overflow: 'visible'\n};\nconst menuDefaultPropsBase = { ...sharedMenuDefaultProp,\n  reposition: 'auto',\n  viewScroll: 'initial',\n  transitionTimeout: 200,\n  submenuOpenDelay: 300,\n  submenuCloseDelay: 150\n};\n\nconst withHovering = (WrapppedComponent, name) => {\n  const WithHovering = defineName( /*#__PURE__*/forwardRef((props, ref) => {\n    return /*#__PURE__*/React.createElement(WrapppedComponent, Object.assign({}, props, {\n      externalRef: ref,\n      isHovering: useContext(HoverIndexContext) === props.index\n    }));\n  }), name);\n  WithHovering.displayName = `WithHovering(${name})`;\n  return WithHovering;\n};\n\nconst useActiveState = (isHovering, isDisabled, ...moreKeys) => {\n  const [active, setActive] = useState(false);\n  const activeKeys = [Keys.SPACE, Keys.ENTER, ...moreKeys];\n\n  const cancelActive = () => setActive(false);\n\n  return {\n    isActive: active,\n    onPointerDown: () => {\n      if (!isDisabled) setActive(true);\n    },\n    onPointerUp: cancelActive,\n    onPointerLeave: cancelActive,\n    onKeyDown: e => {\n      if (isHovering && !isDisabled && activeKeys.includes(e.key)) {\n        setActive(true);\n      }\n    },\n    onKeyUp: e => {\n      if (activeKeys.includes(e.key)) {\n        setActive(false);\n      }\n    },\n    onBlur: e => {\n      if (!e.currentTarget.contains(e.relatedTarget)) {\n        setActive(false);\n      }\n    }\n  };\n};\n\nconst useBEM = ({\n  block,\n  element,\n  modifiers,\n  className\n}) => useMemo(() => {\n  const blockElement = element ? `${block}__${element}` : block;\n  let classString = blockElement;\n\n  for (const name of Object.keys(modifiers || {})) {\n    const value = modifiers[name];\n\n    if (value) {\n      classString += ` ${blockElement}--`;\n      classString += value === true ? name : `${name}-${value}`;\n    }\n  }\n\n  let expandedClassName = typeof className === 'function' ? className(modifiers) : className;\n\n  if (typeof expandedClassName === 'string') {\n    expandedClassName = expandedClassName.trim();\n    if (expandedClassName) classString += ` ${expandedClassName}`;\n  }\n\n  return classString;\n}, [block, element, modifiers, className]);\n\nconst setRef = (ref, element) => {\n  if (typeof ref === 'function') {\n    ref(element);\n  } else if (ref) {\n    ref.current = element;\n  }\n};\n\nconst useCombinedRef = (refA, refB) => useMemo(() => {\n  if (!refA) return refB;\n  if (!refB) return refA;\n  return element => {\n    setRef(refA, element);\n    setRef(refB, element);\n  };\n}, [refA, refB]);\n\nconst isObject = obj => obj && typeof obj === 'object';\n\nconst sanitiseKey = key => key.charAt(0) === '$' ? key.slice(1) : key;\n\nconst useFlatStyles = (styles, modifiers) => useMemo(() => {\n  if (typeof styles === 'function') return styles(modifiers);\n  if (!isObject(styles)) return undefined;\n  if (!modifiers) return styles;\n  const style = {};\n\n  for (const prop of Object.keys(styles)) {\n    const value = styles[prop];\n\n    if (isObject(value)) {\n      const modifierValue = modifiers[sanitiseKey(prop)];\n\n      if (typeof modifierValue === 'string') {\n        for (const nestedProp of Object.keys(value)) {\n          const nestedValue = value[nestedProp];\n\n          if (isObject(nestedValue)) {\n            if (sanitiseKey(nestedProp) === modifierValue) {\n              Object.assign(style, nestedValue);\n            }\n          } else {\n            style[nestedProp] = nestedValue;\n          }\n        }\n      } else if (modifierValue) {\n        Object.assign(style, value);\n      }\n    } else {\n      style[prop] = value;\n    }\n  }\n\n  return style;\n}, [styles, modifiers]);\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nconst useItemState = (ref, index, isHovering, isDisabled) => {\n  const {\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const timeoutId = useRef();\n\n  const setHover = () => {\n    if (!isDisabled) dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n  };\n\n  const onBlur = e => {\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const onMouseEnter = () => {\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(setHover, submenuCloseDelay);\n    } else {\n      setHover();\n    }\n  };\n\n  const onMouseLeave = (_, keepHover) => {\n    timeoutId.current && clearTimeout(timeoutId.current);\n    if (!keepHover) dispatch({\n      type: HoverIndexActionTypes.UNSET,\n      index\n    });\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      ref.current && ref.current.focus();\n    }\n  }, [ref, isHovering, isParentOpen]);\n  return {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  };\n};\n\nconst useMenuChange = (onMenuChange, isOpen) => {\n  const prevOpen = useRef(isOpen);\n  useEffect(() => {\n    if (prevOpen.current !== isOpen) safeCall(onMenuChange, {\n      open: isOpen\n    });\n    prevOpen.current = isOpen;\n  }, [onMenuChange, isOpen]);\n};\n\nconst useMenuState = ({\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout\n} = {}) => {\n  const [state, toggleMenu, endTransition] = useTransition({\n    mountOnEnter: !initialMounted,\n    unmountOnExit: unmountOnClose,\n    timeout: transitionTimeout,\n    enter: getTransition(transition, 'open'),\n    exit: getTransition(transition, 'close')\n  });\n  return {\n    state: MenuStateMap[state],\n    toggleMenu,\n    endTransition\n  };\n};\n\nconst useMenuStateAndFocus = options => {\n  const menuState = useMenuState(options);\n  const [menuItemFocus, setMenuItemFocus] = useState({\n    position: FocusPositions.INITIAL\n  });\n\n  const openMenu = (position = FocusPositions.INITIAL) => {\n    setMenuItemFocus({\n      position\n    });\n    menuState.toggleMenu(true);\n  };\n\n  return { ...menuState,\n    openMenu,\n    menuItemFocus\n  };\n};\n\nconst MenuButton = defineName( /*#__PURE__*/forwardRef(function MenuButton({\n  className,\n  styles,\n  isOpen,\n  disabled,\n  children,\n  ...restProps\n}, ref) {\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen\n  }), [isOpen]);\n  return /*#__PURE__*/React.createElement(\"button\", Object.assign({\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": disabled || undefined,\n    disabled: disabled\n  }, restProps, {\n    ref: ref,\n    className: useBEM({\n      block: menuButtonClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), children);\n}), 'MenuButton');\nMenuButton.propTypes = { ...stylePropTypes(),\n  isOpen: PropTypes.bool,\n  disabled: PropTypes.bool,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func,\n  onKeyDown: PropTypes.func\n};\n\nconst getPositionHelpers = ({\n  menuRef,\n  containerRef,\n  scrollingRef,\n  boundingBoxPadding\n}) => {\n  const menuRect = menuRef.current.getBoundingClientRect();\n  const containerRect = containerRef.current.getBoundingClientRect();\n  const boundingRect = scrollingRef.current === window ? {\n    left: 0,\n    top: 0,\n    right: document.documentElement.clientWidth,\n    bottom: window.innerHeight\n  } : scrollingRef.current.getBoundingClientRect();\n  const padding = parsePadding(boundingBoxPadding);\n\n  const getLeftOverflow = x => x + containerRect.left - boundingRect.left - padding.left;\n\n  const getRightOverflow = x => x + containerRect.left + menuRect.width - boundingRect.right + padding.right;\n\n  const getTopOverflow = y => y + containerRect.top - boundingRect.top - padding.top;\n\n  const getBottomOverflow = y => y + containerRect.top + menuRect.height - boundingRect.bottom + padding.bottom;\n\n  const confineHorizontally = x => {\n    let leftOverflow = getLeftOverflow(x);\n\n    if (leftOverflow < 0) {\n      x -= leftOverflow;\n    } else {\n      const rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        x -= rightOverflow;\n        leftOverflow = getLeftOverflow(x);\n        if (leftOverflow < 0) x -= leftOverflow;\n      }\n    }\n\n    return x;\n  };\n\n  const confineVertically = y => {\n    let topOverflow = getTopOverflow(y);\n\n    if (topOverflow < 0) {\n      y -= topOverflow;\n    } else {\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        y -= bottomOverflow;\n        topOverflow = getTopOverflow(y);\n        if (topOverflow < 0) y -= topOverflow;\n      }\n    }\n\n    return y;\n  };\n\n  return {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  };\n};\n\nconst positionContextMenu = ({\n  positionHelpers,\n  anchorPoint\n}) => {\n  const {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  } = positionHelpers;\n  let x, y;\n  x = anchorPoint.x - containerRect.left;\n  y = anchorPoint.y - containerRect.top;\n  const rightOverflow = getRightOverflow(x);\n\n  if (rightOverflow > 0) {\n    const adjustedX = x - menuRect.width;\n    const leftOverflow = getLeftOverflow(adjustedX);\n\n    if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n      x = adjustedX;\n    }\n\n    x = confineHorizontally(x);\n  }\n\n  let computedDirection = 'bottom';\n  const bottomOverflow = getBottomOverflow(y);\n\n  if (bottomOverflow > 0) {\n    const adjustedY = y - menuRect.height;\n    const topOverflow = getTopOverflow(adjustedY);\n\n    if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n      y = adjustedY;\n      computedDirection = 'top';\n    }\n\n    y = confineVertically(y);\n  }\n\n  return {\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowVertical = ({\n  arrowRef,\n  menuY,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let y = anchorRect.top - containerRect.top - menuY + anchorRect.height / 2;\n  const offset = arrowRef.current.offsetHeight * 1.25;\n  y = Math.max(offset, y);\n  y = Math.min(y, menuRect.height - offset);\n  return y;\n};\n\nconst placeLeftorRight = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeLeftorRightY,\n  placeLeftX,\n  placeRightX,\n  getLeftOverflow,\n  getRightOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction;\n  let y = placeLeftorRightY;\n\n  if (position !== 'initial') {\n    y = confineVertically(y);\n\n    if (position === 'anchor') {\n      y = Math.min(y, anchorRect.bottom - containerRect.top);\n      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);\n    }\n  }\n\n  let x, leftOverflow, rightOverflow;\n\n  if (computedDirection === 'left') {\n    x = placeLeftX;\n\n    if (position !== 'initial') {\n      leftOverflow = getLeftOverflow(x);\n\n      if (leftOverflow < 0) {\n        rightOverflow = getRightOverflow(placeRightX);\n\n        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {\n          x = placeRightX;\n          computedDirection = 'right';\n        }\n      }\n    }\n  } else {\n    x = placeRightX;\n\n    if (position !== 'initial') {\n      rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        leftOverflow = getLeftOverflow(placeLeftX);\n\n        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n          x = placeLeftX;\n          computedDirection = 'left';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') x = confineHorizontally(x);\n  const arrowY = arrow ? placeArrowVertical({\n    menuY: y,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowY,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowHorizontal = ({\n  arrowRef,\n  menuX,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let x = anchorRect.left - containerRect.left - menuX + anchorRect.width / 2;\n  const offset = arrowRef.current.offsetWidth * 1.25;\n  x = Math.max(offset, x);\n  x = Math.min(x, menuRect.width - offset);\n  return x;\n};\n\nconst placeToporBottom = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeToporBottomX,\n  placeTopY,\n  placeBottomY,\n  getTopOverflow,\n  getBottomOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction === 'top' ? 'top' : 'bottom';\n  let x = placeToporBottomX;\n\n  if (position !== 'initial') {\n    x = confineHorizontally(x);\n\n    if (position === 'anchor') {\n      x = Math.min(x, anchorRect.right - containerRect.left);\n      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);\n    }\n  }\n\n  let y, topOverflow, bottomOverflow;\n\n  if (computedDirection === 'top') {\n    y = placeTopY;\n\n    if (position !== 'initial') {\n      topOverflow = getTopOverflow(y);\n\n      if (topOverflow < 0) {\n        bottomOverflow = getBottomOverflow(placeBottomY);\n\n        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {\n          y = placeBottomY;\n          computedDirection = 'bottom';\n        }\n      }\n    }\n  } else {\n    y = placeBottomY;\n\n    if (position !== 'initial') {\n      bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        topOverflow = getTopOverflow(placeTopY);\n\n        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n          y = placeTopY;\n          computedDirection = 'top';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') y = confineVertically(y);\n  const arrowX = arrow ? placeArrowHorizontal({\n    menuX: x,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowX,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst positionMenu = ({\n  arrow,\n  align,\n  direction,\n  offsetX,\n  offsetY,\n  position,\n  anchorRef,\n  arrowRef,\n  positionHelpers\n}) => {\n  const {\n    menuRect,\n    containerRect\n  } = positionHelpers;\n  let horizontalOffset = offsetX;\n  let verticalOffset = offsetY;\n\n  if (arrow) {\n    if (direction === 'left' || direction === 'right') {\n      horizontalOffset += arrowRef.current.offsetWidth;\n    } else {\n      verticalOffset += arrowRef.current.offsetHeight;\n    }\n  }\n\n  const anchorRect = anchorRef.current.getBoundingClientRect();\n  const placeLeftX = anchorRect.left - containerRect.left - menuRect.width - horizontalOffset;\n  const placeRightX = anchorRect.right - containerRect.left + horizontalOffset;\n  const placeTopY = anchorRect.top - containerRect.top - menuRect.height - verticalOffset;\n  const placeBottomY = anchorRect.bottom - containerRect.top + verticalOffset;\n  let placeToporBottomX, placeLeftorRightY;\n\n  if (align === 'end') {\n    placeToporBottomX = anchorRect.right - containerRect.left - menuRect.width;\n    placeLeftorRightY = anchorRect.bottom - containerRect.top - menuRect.height;\n  } else if (align === 'center') {\n    placeToporBottomX = anchorRect.left - containerRect.left - (menuRect.width - anchorRect.width) / 2;\n    placeLeftorRightY = anchorRect.top - containerRect.top - (menuRect.height - anchorRect.height) / 2;\n  } else {\n    placeToporBottomX = anchorRect.left - containerRect.left;\n    placeLeftorRightY = anchorRect.top - containerRect.top;\n  }\n\n  placeToporBottomX += horizontalOffset;\n  placeLeftorRightY += verticalOffset;\n  const options = { ...positionHelpers,\n    anchorRect,\n    placeLeftX,\n    placeRightX,\n    placeLeftorRightY,\n    placeTopY,\n    placeBottomY,\n    placeToporBottomX,\n    arrowRef,\n    arrow,\n    direction,\n    position\n  };\n\n  switch (direction) {\n    case 'left':\n    case 'right':\n      return placeLeftorRight(options);\n\n    case 'top':\n    case 'bottom':\n    default:\n      return placeToporBottom(options);\n  }\n};\n\nconst MenuList = ({\n  ariaLabel,\n  menuClassName,\n  menuStyles,\n  arrowClassName,\n  arrowStyles,\n  anchorPoint,\n  anchorRef,\n  containerRef,\n  externalRef,\n  parentScrollingRef,\n  arrow,\n  align,\n  direction,\n  position,\n  overflow,\n  repositionFlag,\n  captureFocus: _captureFocus = true,\n  state: menuState,\n  endTransition,\n  isDisabled,\n  menuItemFocus,\n  offsetX,\n  offsetY,\n  children,\n  onClose,\n  ...restProps\n}) => {\n  const isOpen = isMenuOpen(menuState);\n  const [menuPosition, setMenuPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [arrowPosition, setArrowPosition] = useState({});\n  const [overflowData, setOverflowData] = useState();\n  const [expandedDirection, setExpandedDirection] = useState(direction);\n  const {\n    transition,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef,\n    rootAnchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  } = useContext(SettingsContext);\n  const menuRef = useRef(null);\n  const arrowRef = useRef(null);\n  const menuItemsCount = useRef(0);\n  const prevOpen = useRef(isOpen);\n  const latestMenuSize = useRef({\n    width: 0,\n    height: 0\n  });\n  const latestHandlePosition = useRef(() => {});\n  const descendOverflowRef = useRef(false);\n  const reposFlag = useContext(MenuListContext).reposSubmenu || repositionFlag;\n  const [reposSubmenu, forceReposSubmenu] = useReducer(c => c + 1, 1);\n  const [{\n    hoverIndex,\n    openSubmenuCount\n  }, dispatch] = useReducer(reducer, {\n    hoverIndex: initialHoverIndex,\n    openSubmenuCount: 0\n  });\n  const openTransition = getTransition(transition, 'open');\n  const closeTransition = getTransition(transition, 'close');\n\n  function reducer({\n    hoverIndex,\n    openSubmenuCount\n  }, action) {\n    return {\n      hoverIndex: hoverIndexReducer(hoverIndex, action),\n      openSubmenuCount: submenuCountReducer(openSubmenuCount, action)\n    };\n  }\n\n  function hoverIndexReducer(state, {\n    type,\n    index\n  }) {\n    switch (type) {\n      case HoverIndexActionTypes.RESET:\n        return initialHoverIndex;\n\n      case HoverIndexActionTypes.SET:\n        return index;\n\n      case HoverIndexActionTypes.UNSET:\n        return state === index ? initialHoverIndex : state;\n\n      case HoverIndexActionTypes.DECREASE:\n        {\n          let i = state;\n          i--;\n          if (i < 0) i = menuItemsCount.current - 1;\n          return i;\n        }\n\n      case HoverIndexActionTypes.INCREASE:\n        {\n          let i = state;\n          i++;\n          if (i >= menuItemsCount.current) i = 0;\n          return i;\n        }\n\n      case HoverIndexActionTypes.FIRST:\n        return menuItemsCount.current > 0 ? 0 : initialHoverIndex;\n\n      case HoverIndexActionTypes.LAST:\n        return menuItemsCount.current > 0 ? menuItemsCount.current - 1 : initialHoverIndex;\n\n      default:\n        return state;\n    }\n  }\n\n  const menuItems = useMemo(() => {\n    const {\n      items,\n      endIndex,\n      descendOverflow\n    } = cloneChildren(children);\n    menuItemsCount.current = endIndex;\n    descendOverflowRef.current = descendOverflow;\n    return items;\n  }, [children]);\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.HOME:\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n        handled = true;\n        break;\n\n      case Keys.END:\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n        handled = true;\n        break;\n\n      case Keys.UP:\n        dispatch({\n          type: HoverIndexActionTypes.DECREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        dispatch({\n          type: HoverIndexActionTypes.INCREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.SPACE:\n        if (e.target && e.target.className.includes(menuClass)) {\n          e.preventDefault();\n        }\n\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleAnimationEnd = () => {\n    if (menuState === 'closing') {\n      setOverflowData();\n    }\n\n    safeCall(endTransition);\n  };\n\n  const handlePosition = useCallback(() => {\n    if (!containerRef.current) {\n      if (!isProd) throw new Error('[react-menu] Menu cannot be positioned properly as container ref is null. If you initialise isOpen prop to true for ControlledMenu, please see this link for a solution: https://github.com/szhsin/react-menu/issues/2#issuecomment-719166062');\n      return;\n    }\n\n    if (!scrollingRef.current) {\n      scrollingRef.current = boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current);\n    }\n\n    const positionHelpers = getPositionHelpers({\n      menuRef,\n      containerRef,\n      scrollingRef,\n      boundingBoxPadding\n    });\n    const {\n      menuRect\n    } = positionHelpers;\n    let results = {\n      computedDirection: 'bottom'\n    };\n\n    if (anchorPoint) {\n      results = positionContextMenu({\n        positionHelpers,\n        anchorPoint\n      });\n    } else if (anchorRef) {\n      results = positionMenu({\n        arrow,\n        align,\n        direction,\n        offsetX,\n        offsetY,\n        position,\n        anchorRef,\n        arrowRef,\n        positionHelpers\n      });\n    }\n\n    let {\n      arrowX,\n      arrowY,\n      x,\n      y,\n      computedDirection\n    } = results;\n    let menuHeight = menuRect.height;\n\n    if (overflow !== 'visible') {\n      const {\n        getTopOverflow,\n        getBottomOverflow\n      } = positionHelpers;\n      let height, overflowAmt;\n      const prevHeight = latestMenuSize.current.height;\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n        height = menuHeight - bottomOverflow;\n        overflowAmt = bottomOverflow;\n      } else {\n        const topOverflow = getTopOverflow(y);\n\n        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n          height = menuHeight + topOverflow;\n          overflowAmt = 0 - topOverflow;\n          if (height >= 0) y -= topOverflow;\n        }\n      }\n\n      if (height >= 0) {\n        menuHeight = height;\n        setOverflowData({\n          height,\n          overflowAmt\n        });\n      } else {\n        setOverflowData();\n      }\n    }\n\n    if (arrow) setArrowPosition({\n      x: arrowX,\n      y: arrowY\n    });\n    setMenuPosition({\n      x,\n      y\n    });\n    setExpandedDirection(computedDirection);\n    latestMenuSize.current = {\n      width: menuRect.width,\n      height: menuHeight\n    };\n  }, [arrow, align, boundingBoxPadding, direction, offsetX, offsetY, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollingRef]);\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      handlePosition();\n      if (prevOpen.current) forceReposSubmenu();\n    }\n\n    prevOpen.current = isOpen;\n    latestHandlePosition.current = handlePosition;\n  }, [isOpen, handlePosition, reposFlag]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowData && !descendOverflowRef.current) menuRef.current.scrollTop = 0;\n  }, [overflowData]);\n  useEffect(() => {\n    if (!isOpen) return;\n\n    if (!anchorScrollingRef.current && rootAnchorRef && rootAnchorRef.current.tagName) {\n      anchorScrollingRef.current = getScrollAncestor(rootAnchorRef.current);\n    }\n\n    const scrollCurrent = scrollingRef.current;\n    const menuScroll = scrollCurrent && scrollCurrent.addEventListener ? scrollCurrent : window;\n    const anchorScroll = anchorScrollingRef.current || menuScroll;\n    let scroll = viewScroll;\n    if (anchorScroll !== menuScroll && scroll === 'initial') scroll = 'auto';\n    if (scroll === 'initial') return;\n    if (scroll === 'auto' && overflow !== 'visible') scroll = 'close';\n\n    const handleScroll = () => {\n      if (scroll === 'auto') {\n        batchedUpdates(handlePosition);\n      } else {\n        safeCall(onClose, {\n          reason: CloseReason.SCROLL\n        });\n      }\n    };\n\n    const scrollObservers = anchorScroll !== menuScroll && viewScroll !== 'initial' ? [anchorScroll, menuScroll] : [anchorScroll];\n    scrollObservers.forEach(o => o.addEventListener('scroll', handleScroll));\n    return () => scrollObservers.forEach(o => o.removeEventListener('scroll', handleScroll));\n  }, [rootAnchorRef, anchorScrollingRef, scrollingRef, isOpen, overflow, onClose, viewScroll, handlePosition]);\n  const hasOverflow = Boolean(overflowData) && overflowData.overflowAmt > 0;\n  useEffect(() => {\n    if (hasOverflow || !isOpen || !parentScrollingRef) return;\n\n    const handleScroll = () => batchedUpdates(handlePosition);\n\n    const parentScroll = parentScrollingRef.current;\n    parentScroll.addEventListener('scroll', handleScroll);\n    return () => parentScroll.removeEventListener('scroll', handleScroll);\n  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);\n  useEffect(() => {\n    if (typeof ResizeObserver !== 'function' || reposition === 'initial') return;\n    const resizeObserver = new ResizeObserver(([entry]) => {\n      const {\n        borderBoxSize,\n        target\n      } = entry;\n      let width, height;\n\n      if (borderBoxSize) {\n        const {\n          inlineSize,\n          blockSize\n        } = borderBoxSize[0] || borderBoxSize;\n        width = inlineSize;\n        height = blockSize;\n      } else {\n        const borderRect = target.getBoundingClientRect();\n        width = borderRect.width;\n        height = borderRect.height;\n      }\n\n      if (width === 0 || height === 0) return;\n      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1)) return;\n      batchedUpdates(() => {\n        latestHandlePosition.current();\n        forceReposSubmenu();\n      });\n    });\n    const observeTarget = menuRef.current;\n    resizeObserver.observe(observeTarget, {\n      box: 'border-box'\n    });\n    return () => resizeObserver.unobserve(observeTarget);\n  }, [reposition]);\n  useEffect(() => {\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.RESET\n      });\n      if (!closeTransition) setOverflowData();\n    }\n\n    const id = setTimeout(() => {\n      if (!isOpen || !menuRef.current || menuRef.current.contains(document.activeElement)) return;\n      if (_captureFocus) menuRef.current.focus();\n\n      if (menuItemFocus.position === FocusPositions.FIRST) {\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n      } else if (menuItemFocus.position === FocusPositions.LAST) {\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n      }\n    }, openTransition ? 170 : 100);\n    return () => clearTimeout(id);\n  }, [openTransition, closeTransition, _captureFocus, isOpen, menuItemFocus]);\n  const isSubmenuOpen = openSubmenuCount > 0;\n  const itemContext = useMemo(() => ({\n    parentMenuRef: menuRef,\n    parentOverflow: overflow,\n    isParentOpen: isOpen,\n    isSubmenuOpen,\n    dispatch\n  }), [isOpen, isSubmenuOpen, overflow]);\n  let maxHeight, overflowAmt;\n\n  if (overflowData) {\n    descendOverflowRef.current ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;\n  }\n\n  const listContext = useMemo(() => ({\n    reposSubmenu,\n    overflow,\n    overflowAmt\n  }), [reposSubmenu, overflow, overflowAmt]);\n  const overflowStyles = maxHeight >= 0 ? {\n    maxHeight,\n    overflow\n  } : undefined;\n  const modifiers = useMemo(() => ({\n    state: menuState,\n    dir: expandedDirection\n  }), [menuState, expandedDirection]);\n  const arrowModifiers = useMemo(() => Object.freeze({\n    dir: expandedDirection\n  }), [expandedDirection]);\n\n  const _arrowClass = useBEM({\n    block: menuClass,\n    element: menuArrowClass,\n    modifiers: arrowModifiers,\n    className: arrowClassName\n  });\n\n  const _arrowStyles = useFlatStyles(arrowStyles, arrowModifiers);\n\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onAnimationEnd: handleAnimationEnd\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"menu\",\n    tabIndex: \"-1\",\n    \"aria-disabled\": isDisabled || undefined,\n    \"aria-label\": ariaLabel\n  }, restProps, handlers, {\n    ref: useCombinedRef(externalRef, menuRef),\n    className: useBEM({\n      block: menuClass,\n      modifiers,\n      className: menuClassName\n    }),\n    style: { ...useFlatStyles(menuStyles, modifiers),\n      ...overflowStyles,\n      left: `${menuPosition.x}px`,\n      top: `${menuPosition.y}px`\n    }\n  }), arrow && /*#__PURE__*/React.createElement(\"div\", {\n    className: _arrowClass,\n    style: { ..._arrowStyles,\n      left: arrowPosition.x && `${arrowPosition.x}px`,\n      top: arrowPosition.y && `${arrowPosition.y}px`\n    },\n    ref: arrowRef\n  }), /*#__PURE__*/React.createElement(MenuListContext.Provider, {\n    value: listContext\n  }, /*#__PURE__*/React.createElement(MenuListItemContext.Provider, {\n    value: itemContext\n  }, /*#__PURE__*/React.createElement(HoverIndexContext.Provider, {\n    value: hoverIndex\n  }, menuItems))));\n};\n\nfunction submenuCountReducer(state, {\n  type\n}) {\n  switch (type) {\n    case SubmenuActionTypes.OPEN:\n      return state + 1;\n\n    case SubmenuActionTypes.CLOSE:\n      return Math.max(state - 1, 0);\n\n    default:\n      return state;\n  }\n}\n\nconst ControlledMenu = /*#__PURE__*/forwardRef(function ControlledMenu({\n  'aria-label': ariaLabel,\n  className,\n  containerProps,\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout,\n  boundingBoxRef,\n  boundingBoxPadding,\n  reposition,\n  submenuOpenDelay,\n  submenuCloseDelay,\n  skipOpen,\n  viewScroll,\n  portal,\n  theming,\n  onItemClick,\n  onClose,\n  ...restProps\n}, externalRef) {\n  const containerRef = useRef(null);\n  const scrollingRef = useRef(null);\n  const anchorScrollingRef = useRef(null);\n  const {\n    anchorRef,\n    state\n  } = restProps;\n  const settings = useMemo(() => ({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef: containerRef,\n    rootAnchorRef: anchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  }), [initialMounted, unmountOnClose, transition, transitionTimeout, anchorRef, boundingBoxRef, boundingBoxPadding, reposition, viewScroll]);\n  const itemSettings = useMemo(() => ({\n    submenuOpenDelay,\n    submenuCloseDelay\n  }), [submenuOpenDelay, submenuCloseDelay]);\n  const eventHandlers = useMemo(() => ({\n    handleClick(event, isCheckorRadio) {\n      if (!event.stopPropagation) safeCall(onItemClick, event);\n      let keepOpen = event.keepOpen;\n\n      if (keepOpen === undefined) {\n        keepOpen = isCheckorRadio && event.key === Keys.SPACE;\n      }\n\n      if (!keepOpen) {\n        safeCall(onClose, {\n          value: event.value,\n          key: event.key,\n          reason: CloseReason.CLICK\n        });\n      }\n    },\n\n    handleClose(key) {\n      safeCall(onClose, {\n        key,\n        reason: CloseReason.CLICK\n      });\n    }\n\n  }), [onItemClick, onClose]);\n\n  const handleKeyDown = ({\n    key\n  }) => {\n    switch (key) {\n      case Keys.ESC:\n        safeCall(onClose, {\n          key,\n          reason: CloseReason.CANCEL\n        });\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    if (isMenuOpen(state) && !e.currentTarget.contains(e.relatedTarget || document.activeElement)) {\n      safeCall(onClose, {\n        reason: CloseReason.BLUR\n      });\n\n      if (skipOpen) {\n        skipOpen.current = true;\n        setTimeout(() => skipOpen.current = false, 300);\n      }\n    }\n  };\n\n  const itemTransition = getTransition(transition, 'item');\n  const modifiers = useMemo(() => ({\n    theme: theming,\n    itemTransition\n  }), [theming, itemTransition]);\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur\n  }, containerProps);\n  const menuList = /*#__PURE__*/React.createElement(\"div\", Object.assign({}, containerProps, handlers, {\n    className: useBEM({\n      block: menuContainerClass,\n      modifiers,\n      className\n    }),\n    ref: containerRef\n  }), state && /*#__PURE__*/React.createElement(SettingsContext.Provider, {\n    value: settings\n  }, /*#__PURE__*/React.createElement(ItemSettingsContext.Provider, {\n    value: itemSettings\n  }, /*#__PURE__*/React.createElement(EventHandlersContext.Provider, {\n    value: eventHandlers\n  }, /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, {\n    ariaLabel: ariaLabel || 'Menu',\n    externalRef: externalRef,\n    containerRef: containerRef,\n    onClose: onClose\n  }))))));\n\n  if (portal) {\n    return /*#__PURE__*/ReactDOM.createPortal(menuList, document.body);\n  } else {\n    return menuList;\n  }\n});\nControlledMenu.propTypes = { ...menuPropTypesBase,\n  state: PropTypes.oneOf(values(MenuStateMap)),\n  anchorPoint: PropTypes.exact({\n    x: PropTypes.number,\n    y: PropTypes.number\n  }),\n  anchorRef: PropTypes.object,\n  skipOpen: PropTypes.object,\n  captureFocus: PropTypes.bool,\n  menuItemFocus: PropTypes.exact({\n    position: PropTypes.string\n  }),\n  onClose: PropTypes.func\n};\nControlledMenu.defaultProps = { ...menuDefaultPropsBase,\n  menuItemFocus: {\n    position: FocusPositions.INITIAL\n  }\n};\nconst Menu = /*#__PURE__*/forwardRef(function Menu({\n  'aria-label': ariaLabel,\n  captureFocus: _,\n  menuButton,\n  onMenuChange,\n  ...restProps\n}, externalRef) {\n  const {\n    openMenu,\n    toggleMenu,\n    ...stateProps\n  } = useMenuStateAndFocus(restProps);\n  const isOpen = isMenuOpen(stateProps.state);\n  const skipOpen = useRef(false);\n  const buttonRef = useRef(null);\n  const handleClose = useCallback(e => {\n    toggleMenu(false);\n    if (e.key) buttonRef.current.focus();\n  }, [toggleMenu]);\n\n  const handleClick = e => {\n    if (skipOpen.current) return;\n    openMenu(e.detail === 0 ? FocusPositions.FIRST : FocusPositions.INITIAL);\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.UP:\n        openMenu(FocusPositions.LAST);\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        openMenu(FocusPositions.FIRST);\n        handled = true;\n        break;\n    }\n\n    if (handled) e.preventDefault();\n  };\n\n  const button = safeCall(menuButton, {\n    open: isOpen\n  });\n  if (!button) throw new Error('Menu requires a menuButton prop.');\n  const buttonProps = {\n    ref: useCombinedRef(button.ref, buttonRef),\n    ...attachHandlerProps({\n      onClick: handleClick,\n      onKeyDown: handleKeyDown\n    }, button.props)\n  };\n\n  if (getName(button.type) === 'MenuButton') {\n    buttonProps.isOpen = isOpen;\n  }\n\n  const renderButton = /*#__PURE__*/React.cloneElement(button, buttonProps);\n  useMenuChange(onMenuChange, isOpen);\n  const menuProps = { ...restProps,\n    ...stateProps,\n    'aria-label': ariaLabel || (typeof button.props.children === 'string' ? button.props.children : 'Menu'),\n    anchorRef: buttonRef,\n    ref: externalRef,\n    onClose: handleClose,\n    skipOpen\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, renderButton, /*#__PURE__*/React.createElement(ControlledMenu, menuProps));\n});\nMenu.propTypes = { ...menuPropTypesBase,\n  menuButton: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,\n  onMenuChange: PropTypes.func\n};\nMenu.defaultProps = menuDefaultPropsBase;\nconst SubMenu = withHovering( /*#__PURE__*/memo(function SubMenu({\n  'aria-label': ariaLabel,\n  className,\n  disabled,\n  label,\n  index,\n  onMenuChange,\n  isHovering,\n  captureFocus: _1,\n  repositionFlag: _2,\n  itemProps = {},\n  ...restProps\n}) {\n  const {\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    rootMenuRef\n  } = useContext(SettingsContext);\n  const {\n    submenuOpenDelay,\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    parentMenuRef,\n    parentOverflow,\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const isPortal = parentOverflow !== 'visible';\n  const {\n    openMenu,\n    toggleMenu,\n    state,\n    ...otherStateProps\n  } = useMenuStateAndFocus({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout\n  });\n  const isOpen = isMenuOpen(state);\n  const isDisabled = Boolean(disabled);\n  const {\n    isActive,\n    onKeyUp,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled, Keys.RIGHT);\n  const containerRef = useRef(null);\n  const itemRef = useRef(null);\n  const timeoutId = useRef();\n\n  const delayOpen = delay => {\n    dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n    timeoutId.current = setTimeout(openMenu, Math.max(delay, 0));\n  };\n\n  const handleMouseEnter = () => {\n    if (isDisabled || isOpen) return;\n\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(() => delayOpen(submenuOpenDelay - submenuCloseDelay), submenuCloseDelay);\n    } else {\n      delayOpen(submenuOpenDelay);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    clearTimeout(timeoutId.current);\n\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const handleClick = () => {\n    if (isDisabled) return;\n    clearTimeout(timeoutId.current);\n    openMenu();\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.LEFT:\n        if (isOpen) {\n          toggleMenu(false);\n          itemRef.current.focus();\n          handled = true;\n        }\n\n        break;\n\n      case Keys.RIGHT:\n        if (!isOpen) handled = true;\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.SPACE:\n      case Keys.ENTER:\n      case Keys.RIGHT:\n        openMenu(FocusPositions.FIRST);\n        break;\n    }\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      itemRef.current.focus();\n    } else {\n      toggleMenu(false);\n    }\n  }, [isHovering, isParentOpen, toggleMenu]);\n  useEffect(() => {\n    dispatch({\n      type: isOpen ? SubmenuActionTypes.OPEN : SubmenuActionTypes.CLOSE\n    });\n  }, [dispatch, isOpen]);\n  useMenuChange(onMenuChange, isOpen);\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen,\n    hover: isHovering,\n    active: isActive,\n    disabled: isDisabled\n  }), [isOpen, isHovering, isActive, isDisabled]);\n  const {\n    ref: externaItemlRef,\n    className: itemClassName,\n    styles: itemStyles,\n    ...restItemProps\n  } = itemProps;\n  const itemHandlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onMouseDown: () => !isHovering && dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    }),\n    onClick: handleClick,\n    onKeyUp: handleKeyUp\n  }, restItemProps);\n\n  const getMenuList = () => {\n    const menuList = /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, otherStateProps, {\n      state: state,\n      ariaLabel: ariaLabel || (typeof label === 'string' ? label : 'Submenu'),\n      anchorRef: itemRef,\n      containerRef: isPortal ? rootMenuRef : containerRef,\n      parentScrollingRef: isPortal && parentMenuRef,\n      isDisabled: isDisabled\n    }));\n    return isPortal ? /*#__PURE__*/createPortal(menuList, rootMenuRef.current) : menuList;\n  };\n\n  return /*#__PURE__*/React.createElement(\"li\", {\n    className: useBEM({\n      block: menuClass,\n      element: subMenuClass,\n      className\n    }),\n    role: \"presentation\",\n    ref: containerRef,\n    onKeyDown: handleKeyDown\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    role: \"menuitem\",\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": isDisabled || undefined,\n    tabIndex: isHovering && !isOpen ? 0 : -1\n  }, restItemProps, itemHandlers, {\n    ref: useCombinedRef(externaItemlRef, itemRef),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className: itemClassName\n    }),\n    style: useFlatStyles(itemStyles, modifiers)\n  }), useMemo(() => safeCall(label, modifiers), [label, modifiers])), state && getMenuList());\n}), 'SubMenu');\nSubMenu.propTypes = { ...sharedMenuPropTypes,\n  disabled: PropTypes.bool,\n  label: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  itemProps: PropTypes.shape({ ...stylePropTypes()\n  }),\n  onMenuChange: PropTypes.func\n};\nSubMenu.defaultProps = { ...sharedMenuDefaultProp,\n  direction: 'right'\n};\nconst MenuItem = withHovering( /*#__PURE__*/memo(function MenuItem({\n  className,\n  styles,\n  value,\n  href,\n  type,\n  checked,\n  disabled,\n  index,\n  children,\n  onClick,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = Boolean(disabled);\n  const ref = useRef();\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const eventHandlers = useContext(EventHandlersContext);\n  const radioGroup = useContext(RadioGroupContext);\n  const {\n    isActive,\n    onKeyUp,\n    onBlur: activeStateBlur,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled);\n  const isRadio = type === 'radio';\n  const isCheckBox = type === 'checkbox';\n  const isAnchor = Boolean(href) && !isDisabled && !isRadio && !isCheckBox;\n  const isChecked = isRadio ? radioGroup.value === value : isCheckBox ? Boolean(checked) : false;\n\n  const handleClick = e => {\n    if (isDisabled) return;\n    const event = {\n      value,\n      syntheticEvent: e\n    };\n    if (e.key !== undefined) event.key = e.key;\n    if (isCheckBox) event.checked = !isChecked;\n\n    if (isRadio) {\n      event.name = radioGroup.name;\n      safeCall(radioGroup.onRadioChange, event);\n    }\n\n    if (!event.stopPropagation) safeCall(onClick, event);\n    eventHandlers.handleClick(event, isCheckBox || isRadio);\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.SPACE:\n      case Keys.ENTER:\n        if (isAnchor) {\n          ref.current.click();\n        } else {\n          handleClick(e);\n        }\n\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    activeStateBlur(e);\n    onBlur(e);\n  };\n\n  const modifiers = useMemo(() => Object.freeze({\n    type,\n    disabled: isDisabled,\n    hover: isHovering,\n    active: isActive,\n    checked: isChecked,\n    anchor: isAnchor\n  }), [type, isDisabled, isHovering, isActive, isChecked, isAnchor]);\n  const handlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown: setHover,\n    onKeyUp: handleKeyUp,\n    onBlur: handleBlur,\n    onClick: handleClick\n  }, restProps);\n  const menuItemProps = {\n    role: isRadio ? 'menuitemradio' : isCheckBox ? 'menuitemcheckbox' : 'menuitem',\n    'aria-checked': isRadio || isCheckBox ? isChecked : undefined,\n    'aria-disabled': isDisabled || undefined,\n    tabIndex: isHovering ? 0 : -1,\n    ...restProps,\n    ...handlers,\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  };\n  const renderChildren = useMemo(() => safeCall(children, modifiers), [children, modifiers]);\n\n  if (isAnchor) {\n    return /*#__PURE__*/React.createElement(\"li\", {\n      role: \"presentation\"\n    }, /*#__PURE__*/React.createElement(\"a\", Object.assign({}, menuItemProps, {\n      href: href\n    }), renderChildren));\n  } else {\n    return /*#__PURE__*/React.createElement(\"li\", menuItemProps, renderChildren);\n  }\n}), 'MenuItem');\nMenuItem.propTypes = { ...stylePropTypes(),\n  value: PropTypes.any,\n  href: PropTypes.string,\n  type: PropTypes.oneOf(['checkbox', 'radio']),\n  checked: PropTypes.bool,\n  disabled: PropTypes.bool,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  onClick: PropTypes.func\n};\nconst FocusableItem = withHovering( /*#__PURE__*/memo(function FocusableItem({\n  className,\n  styles,\n  disabled,\n  index,\n  children,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = Boolean(disabled);\n  const ref = useRef(null);\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const {\n    handleClose\n  } = useContext(EventHandlersContext);\n  const modifiers = useMemo(() => Object.freeze({\n    disabled: isDisabled,\n    hover: isHovering,\n    focusable: true\n  }), [isDisabled, isHovering]);\n  const renderChildren = useMemo(() => safeCall(children, { ...modifiers,\n    ref,\n    closeMenu: handleClose\n  }), [children, modifiers, handleClose]);\n  const handlers = attachHandlerProps({\n    onMouseEnter,\n    onMouseLeave: e => onMouseLeave(e, true),\n    onFocus: setHover,\n    onBlur\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    \"aria-disabled\": isDisabled || undefined,\n    role: \"menuitem\",\n    tabIndex: \"-1\"\n  }, restProps, handlers, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), renderChildren);\n}), 'FocusableItem');\nFocusableItem.propTypes = { ...stylePropTypes(),\n  disabled: PropTypes.bool,\n  children: PropTypes.func.isRequired\n};\nconst MenuDivider = defineName( /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuDivider({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"separator\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuDividerClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n})), 'MenuDivider');\nMenuDivider.propTypes = { ...stylePropTypes()\n};\nconst MenuHeader = defineName( /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuHeader({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"presentation\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuHeaderClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n})), 'MenuHeader');\nMenuHeader.propTypes = { ...stylePropTypes()\n};\nconst MenuGroup = defineName( /*#__PURE__*/forwardRef(function MenuGroup({\n  className,\n  styles,\n  takeOverflow,\n  ...restProps\n}, externalRef) {\n  const ref = useRef(null);\n  const [overflowStyles, setOverflowStyles] = useState();\n  const {\n    overflow,\n    overflowAmt\n  } = useContext(MenuListContext);\n  useIsomorphicLayoutEffect(() => {\n    let maxHeight;\n\n    if (takeOverflow && overflowAmt >= 0) {\n      maxHeight = ref.current.getBoundingClientRect().height - overflowAmt;\n      if (maxHeight < 0) maxHeight = 0;\n    }\n\n    setOverflowStyles(maxHeight >= 0 ? {\n      maxHeight,\n      overflow\n    } : undefined);\n  }, [takeOverflow, overflow, overflowAmt]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowStyles) ref.current.scrollTop = 0;\n  }, [overflowStyles]);\n  return /*#__PURE__*/React.createElement(\"div\", Object.assign({}, restProps, {\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuGroupClass,\n      className\n    }),\n    style: { ...useFlatStyles(styles),\n      ...overflowStyles\n    }\n  }));\n}), 'MenuGroup');\nMenuGroup.propTypes = { ...stylePropTypes(),\n  takeOverflow: PropTypes.bool\n};\nconst MenuRadioGroup = defineName( /*#__PURE__*/forwardRef(function MenuRadioGroup({\n  'aria-label': ariaLabel,\n  className,\n  styles,\n  name,\n  value,\n  children,\n  onRadioChange,\n  ...restProps\n}, externalRef) {\n  const contextValue = useMemo(() => ({\n    name,\n    value,\n    onRadioChange\n  }), [name, value, onRadioChange]);\n  return /*#__PURE__*/React.createElement(\"li\", {\n    role: \"presentation\"\n  }, /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"group\",\n    \"aria-label\": ariaLabel || name || 'Radio group'\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: radioGroupClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }), /*#__PURE__*/React.createElement(RadioGroupContext.Provider, {\n    value: contextValue\n  }, children)));\n}), 'MenuRadioGroup');\nMenuRadioGroup.propTypes = { ...stylePropTypes(),\n  name: PropTypes.string,\n  value: PropTypes.any,\n  children: PropTypes.node.isRequired,\n  onRadioChange: PropTypes.func\n};\nexport { ControlledMenu, FocusableItem, Menu, MenuButton, MenuDivider, MenuGroup, MenuHeader, MenuItem, MenuRadioGroup, SubMenu, applyHOC, applyStatics, useMenuState };","map":{"version":3,"sources":["C:/Users/User/Desktop/reacttest/node_modules/@szhsin/react-menu/dist/index.modern.js"],"names":["React","forwardRef","useContext","useState","useMemo","useLayoutEffect","useEffect","useRef","useReducer","useCallback","memo","ReactDOM","unstable_batchedUpdates","createPortal","PropTypes","useTransition","menuContainerClass","menuClass","menuButtonClass","menuArrowClass","menuItemClass","menuDividerClass","menuHeaderClass","menuGroupClass","subMenuClass","radioGroupClass","initialHoverIndex","HoverIndexContext","createContext","MenuListItemContext","MenuListContext","EventHandlersContext","RadioGroupContext","SettingsContext","ItemSettingsContext","Keys","Object","freeze","HoverIndexActionTypes","SubmenuActionTypes","CloseReason","FocusPositions","MenuStateMap","entering","entered","exiting","exited","batchedUpdates","callback","defineName","component","name","defineProperty","value","writable","getName","applyHOC","HOC","args","applyStatics","sourceComponent","wrappedComponent","safeCall","fn","attachHandlerProps","handlers","props","result","handlerName","keys","handler","propHandler","attachedHandler","e","parsePadding","paddingStr","top","right","bottom","left","padding","trim","split","map","parseFloat","isNaN","getScrollAncestor","node","document","body","overflow","overflowX","overflowY","getComputedStyle","test","parentNode","window","values","obj","key","floatEqual","a","b","diff","Math","abs","isProd","process","env","NODE_ENV","isMenuOpen","state","getTransition","transition","Boolean","validateChildren","parent","child","permitted","includes","type","console","warn","join","cloneChildren","children","startIndex","index","descendOverflow","permittedChildren","items","Children","radioItems","radioChild","disabled","cloneElement","endIndex","descOverflow","takeOverflow","Error","stylePropTypes","oneOfType","string","func","object","sharedMenuPropTypes","className","arrow","bool","offsetX","number","offsetY","align","oneOf","direction","position","isRequired","menuPropTypesBase","containerProps","initialMounted","unmountOnClose","exact","open","close","item","transitionTimeout","boundingBoxRef","boundingBoxPadding","reposition","repositionFlag","viewScroll","submenuOpenDelay","submenuCloseDelay","portal","theming","onItemClick","sharedMenuDefaultProp","menuDefaultPropsBase","withHovering","WrapppedComponent","WithHovering","ref","createElement","assign","externalRef","isHovering","displayName","useActiveState","isDisabled","moreKeys","active","setActive","activeKeys","SPACE","ENTER","cancelActive","isActive","onPointerDown","onPointerUp","onPointerLeave","onKeyDown","onKeyUp","onBlur","currentTarget","contains","relatedTarget","useBEM","block","element","modifiers","blockElement","classString","expandedClassName","setRef","current","useCombinedRef","refA","refB","isObject","sanitiseKey","charAt","slice","useFlatStyles","styles","undefined","style","prop","modifierValue","nestedProp","nestedValue","useIsomorphicLayoutEffect","useItemState","isParentOpen","isSubmenuOpen","dispatch","timeoutId","setHover","SET","UNSET","onMouseEnter","setTimeout","onMouseLeave","_","keepHover","clearTimeout","focus","useMenuChange","onMenuChange","isOpen","prevOpen","useMenuState","toggleMenu","endTransition","mountOnEnter","unmountOnExit","timeout","enter","exit","useMenuStateAndFocus","options","menuState","menuItemFocus","setMenuItemFocus","INITIAL","openMenu","MenuButton","restProps","propTypes","onClick","getPositionHelpers","menuRef","containerRef","scrollingRef","menuRect","getBoundingClientRect","containerRect","boundingRect","documentElement","clientWidth","innerHeight","getLeftOverflow","x","getRightOverflow","width","getTopOverflow","y","getBottomOverflow","height","confineHorizontally","leftOverflow","rightOverflow","confineVertically","topOverflow","bottomOverflow","positionContextMenu","positionHelpers","anchorPoint","adjustedX","computedDirection","adjustedY","placeArrowVertical","arrowRef","menuY","anchorRect","offset","offsetHeight","max","min","placeLeftorRight","placeLeftorRightY","placeLeftX","placeRightX","arrowY","placeArrowHorizontal","menuX","offsetWidth","placeToporBottom","placeToporBottomX","placeTopY","placeBottomY","arrowX","positionMenu","anchorRef","horizontalOffset","verticalOffset","MenuList","ariaLabel","menuClassName","menuStyles","arrowClassName","arrowStyles","parentScrollingRef","captureFocus","_captureFocus","onClose","menuPosition","setMenuPosition","arrowPosition","setArrowPosition","overflowData","setOverflowData","expandedDirection","setExpandedDirection","rootMenuRef","rootAnchorRef","anchorScrollingRef","menuItemsCount","latestMenuSize","latestHandlePosition","descendOverflowRef","reposFlag","reposSubmenu","forceReposSubmenu","c","hoverIndex","openSubmenuCount","reducer","openTransition","closeTransition","action","hoverIndexReducer","submenuCountReducer","RESET","DECREASE","i","INCREASE","FIRST","LAST","menuItems","handleKeyDown","handled","HOME","END","UP","DOWN","target","preventDefault","stopPropagation","handleAnimationEnd","handlePosition","results","menuHeight","overflowAmt","prevHeight","scrollTop","tagName","scrollCurrent","menuScroll","addEventListener","anchorScroll","scroll","handleScroll","reason","SCROLL","scrollObservers","forEach","o","removeEventListener","hasOverflow","parentScroll","ResizeObserver","resizeObserver","entry","borderBoxSize","inlineSize","blockSize","borderRect","observeTarget","observe","box","unobserve","id","activeElement","itemContext","parentMenuRef","parentOverflow","maxHeight","listContext","overflowStyles","dir","arrowModifiers","_arrowClass","_arrowStyles","onAnimationEnd","role","tabIndex","Provider","OPEN","CLOSE","ControlledMenu","skipOpen","settings","itemSettings","eventHandlers","handleClick","event","isCheckorRadio","keepOpen","CLICK","handleClose","ESC","CANCEL","handleBlur","BLUR","itemTransition","theme","menuList","defaultProps","Menu","menuButton","stateProps","buttonRef","detail","button","buttonProps","renderButton","menuProps","Fragment","SubMenu","label","_1","_2","itemProps","isPortal","otherStateProps","activeStateHandlers","RIGHT","itemRef","delayOpen","delay","handleMouseEnter","handleMouseLeave","LEFT","handleKeyUp","hover","externaItemlRef","itemClassName","itemStyles","restItemProps","itemHandlers","onMouseDown","getMenuList","shape","MenuItem","href","checked","radioGroup","activeStateBlur","isRadio","isCheckBox","isAnchor","isChecked","syntheticEvent","onRadioChange","click","anchor","menuItemProps","renderChildren","any","FocusableItem","focusable","closeMenu","onFocus","MenuDivider","MenuHeader","MenuGroup","setOverflowStyles","MenuRadioGroup","contextValue"],"mappings":"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","sourcesContent":["import React, { forwardRef, useContext, useState, useMemo, useLayoutEffect, useEffect, useRef, useReducer, useCallback, memo } from 'react';\nimport ReactDOM, { unstable_batchedUpdates, createPortal } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { useTransition } from 'react-transition-state';\n\nconst menuContainerClass = 'szh-menu-container';\nconst menuClass = 'szh-menu';\nconst menuButtonClass = 'szh-menu-button';\nconst menuArrowClass = 'arrow';\nconst menuItemClass = 'item';\nconst menuDividerClass = 'divider';\nconst menuHeaderClass = 'header';\nconst menuGroupClass = 'group';\nconst subMenuClass = 'submenu';\nconst radioGroupClass = 'radio-group';\nconst initialHoverIndex = -1;\nconst HoverIndexContext = /*#__PURE__*/React.createContext(initialHoverIndex);\nconst MenuListItemContext = /*#__PURE__*/React.createContext({});\nconst MenuListContext = /*#__PURE__*/React.createContext({});\nconst EventHandlersContext = /*#__PURE__*/React.createContext({});\nconst RadioGroupContext = /*#__PURE__*/React.createContext({});\nconst SettingsContext = /*#__PURE__*/React.createContext({});\nconst ItemSettingsContext = /*#__PURE__*/React.createContext({});\nconst Keys = Object.freeze({\n  'ENTER': 'Enter',\n  'ESC': 'Escape',\n  'SPACE': ' ',\n  'HOME': 'Home',\n  'END': 'End',\n  'LEFT': 'ArrowLeft',\n  'RIGHT': 'ArrowRight',\n  'UP': 'ArrowUp',\n  'DOWN': 'ArrowDown'\n});\nconst HoverIndexActionTypes = Object.freeze({\n  'RESET': 'HOVER_INDEX_RESET',\n  'SET': 'HOVER_INDEX_SET',\n  'UNSET': 'HOVER_INDEX_UNSET',\n  'INCREASE': 'HOVER_INDEX_INCREASE',\n  'DECREASE': 'HOVER_INDEX_DECREASE',\n  'FIRST': 'HOVER_INDEX_FIRST',\n  'LAST': 'HOVER_INDEX_LAST'\n});\nconst SubmenuActionTypes = Object.freeze({\n  'OPEN': 'SUBMENU_OPEN',\n  'CLOSE': 'SUBMENU_CLOSE'\n});\nconst CloseReason = Object.freeze({\n  'CLICK': 'click',\n  'CANCEL': 'cancel',\n  'BLUR': 'blur',\n  'SCROLL': 'scroll'\n});\nconst FocusPositions = Object.freeze({\n  'INITIAL': 'initial',\n  'FIRST': 'first',\n  'LAST': 'last'\n});\nconst MenuStateMap = Object.freeze({\n  entering: 'opening',\n  entered: 'open',\n  exiting: 'closing',\n  exited: 'closed'\n});\n\nconst batchedUpdates = unstable_batchedUpdates || (callback => callback());\nconst defineName = (component, name) => name ? Object.defineProperty(component, '_szhsinMenu', {\n  value: name,\n  writable: false\n}) : component;\nconst getName = component => component && component['_szhsinMenu'];\nconst applyHOC = HOC => (...args) => defineName(HOC(...args), getName(args[0]));\nconst applyStatics = sourceComponent => wrappedComponent => defineName(wrappedComponent, getName(sourceComponent));\nconst safeCall = (fn, ...args) => typeof fn === 'function' ? fn(...args) : fn;\nconst attachHandlerProps = (handlers, props) => {\n  if (!props) return handlers;\n  const result = {};\n\n  for (const handlerName of Object.keys(handlers)) {\n    const handler = handlers[handlerName];\n    const propHandler = props[handlerName];\n    let attachedHandler;\n\n    if (typeof propHandler === 'function') {\n      attachedHandler = e => {\n        propHandler(e);\n        handler(e);\n      };\n    } else {\n      attachedHandler = handler;\n    }\n\n    result[handlerName] = attachedHandler;\n  }\n\n  return result;\n};\nconst parsePadding = paddingStr => {\n  if (typeof paddingStr !== 'string') return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  const padding = paddingStr.trim().split(/\\s+/, 4).map(parseFloat);\n  const top = !isNaN(padding[0]) ? padding[0] : 0;\n  const right = !isNaN(padding[1]) ? padding[1] : top;\n  return {\n    top,\n    right,\n    bottom: !isNaN(padding[2]) ? padding[2] : top,\n    left: !isNaN(padding[3]) ? padding[3] : right\n  };\n};\nconst getScrollAncestor = node => {\n  while (node && node !== document.body) {\n    const {\n      overflow,\n      overflowX,\n      overflowY\n    } = getComputedStyle(node);\n    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) return node;\n    node = node.parentNode;\n  }\n\n  return window;\n};\nconst values = Object.values || (obj => Object.keys(obj).map(key => obj[key]));\nconst floatEqual = (a, b, diff = 0.0001) => Math.abs(a - b) < diff;\nconst isProd = process.env.NODE_ENV === 'production';\nconst isMenuOpen = state => state === 'open' || state === 'opening';\nconst getTransition = (transition, name) => Boolean(transition && transition[name]) || transition === true;\n\nconst validateChildren = (parent, child, permitted) => {\n  if (!child) return false;\n\n  if (!permitted.includes(getName(child.type))) {\n    !isProd && console.warn(`[react-menu] ${child.type || child} is ignored.\\n`, `The permitted children inside a ${parent} are ${permitted.join(', ')}.`, 'If you create HOC of these components, you can use the applyHOC or applyStatics helper, see more at: https://szhsin.github.io/react-menu/docs#utils-apply-hoc');\n    return false;\n  }\n\n  return true;\n};\n\nconst cloneChildren = (children, startIndex = 0) => {\n  let index = startIndex;\n  let descendOverflow = false;\n  const permittedChildren = ['MenuDivider', 'MenuGroup', 'MenuHeader', 'MenuItem', 'FocusableItem', 'MenuRadioGroup', 'SubMenu'];\n  const items = React.Children.map(children, child => {\n    if (!validateChildren('Menu or SubMenu', child, permittedChildren)) return null;\n\n    switch (getName(child.type)) {\n      case 'MenuDivider':\n      case 'MenuHeader':\n        return child;\n\n      case 'MenuRadioGroup':\n        {\n          const permittedChildren = ['MenuItem'];\n          const props = {\n            type: 'radio'\n          };\n          const radioItems = React.Children.map(child.props.children, radioChild => {\n            if (!validateChildren('MenuRadioGroup', radioChild, permittedChildren)) return null;\n            return radioChild.props.disabled ? /*#__PURE__*/React.cloneElement(radioChild, props) : /*#__PURE__*/React.cloneElement(radioChild, { ...props,\n              index: index++\n            });\n          });\n          return /*#__PURE__*/React.cloneElement(child, {\n            children: radioItems\n          });\n        }\n\n      case 'MenuGroup':\n        {\n          const {\n            items,\n            endIndex,\n            descendOverflow: descOverflow\n          } = cloneChildren(child.props.children, index);\n          index = endIndex;\n          const takeOverflow = Boolean(child.props.takeOverflow);\n          if (!isProd && (descendOverflow === descOverflow ? descOverflow : takeOverflow)) throw new Error('[react-menu] Only one MenuGroup in a menu is allowed to have takeOverflow prop.');\n          descendOverflow = descendOverflow || descOverflow || takeOverflow;\n          return /*#__PURE__*/React.cloneElement(child, {\n            children: items\n          });\n        }\n\n      default:\n        return child.props.disabled ? child : /*#__PURE__*/React.cloneElement(child, {\n          index: index++\n        });\n    }\n  });\n  return {\n    items,\n    endIndex: index,\n    descendOverflow\n  };\n};\n\nconst stylePropTypes = name => ({\n  [name ? `${name}ClassName` : 'className']: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  [name ? `${name}Styles` : 'styles']: PropTypes.oneOfType([PropTypes.object, PropTypes.func])\n});\nconst sharedMenuPropTypes = {\n  className: PropTypes.string,\n  ...stylePropTypes('menu'),\n  ...stylePropTypes('arrow'),\n  arrow: PropTypes.bool,\n  offsetX: PropTypes.number,\n  offsetY: PropTypes.number,\n  align: PropTypes.oneOf(['start', 'center', 'end']),\n  direction: PropTypes.oneOf(['left', 'right', 'top', 'bottom']),\n  position: PropTypes.oneOf(['auto', 'anchor', 'initial']),\n  overflow: PropTypes.oneOf(['auto', 'visible', 'hidden']),\n  children: PropTypes.node.isRequired\n};\nconst menuPropTypesBase = { ...sharedMenuPropTypes,\n  containerProps: PropTypes.object,\n  initialMounted: PropTypes.bool,\n  unmountOnClose: PropTypes.bool,\n  transition: PropTypes.oneOfType([PropTypes.bool, PropTypes.exact({\n    open: PropTypes.bool,\n    close: PropTypes.bool,\n    item: PropTypes.bool\n  })]),\n  transitionTimeout: PropTypes.number,\n  boundingBoxRef: PropTypes.object,\n  boundingBoxPadding: PropTypes.string,\n  reposition: PropTypes.oneOf(['auto', 'initial']),\n  repositionFlag: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  viewScroll: PropTypes.oneOf(['auto', 'close', 'initial']),\n  submenuOpenDelay: PropTypes.number,\n  submenuCloseDelay: PropTypes.number,\n  portal: PropTypes.bool,\n  theming: PropTypes.string,\n  onItemClick: PropTypes.func\n};\nconst sharedMenuDefaultProp = {\n  offsetX: 0,\n  offsetY: 0,\n  align: 'start',\n  direction: 'bottom',\n  position: 'auto',\n  overflow: 'visible'\n};\nconst menuDefaultPropsBase = { ...sharedMenuDefaultProp,\n  reposition: 'auto',\n  viewScroll: 'initial',\n  transitionTimeout: 200,\n  submenuOpenDelay: 300,\n  submenuCloseDelay: 150\n};\n\nconst withHovering = (WrapppedComponent, name) => {\n  const WithHovering = defineName( /*#__PURE__*/forwardRef((props, ref) => {\n    return /*#__PURE__*/React.createElement(WrapppedComponent, Object.assign({}, props, {\n      externalRef: ref,\n      isHovering: useContext(HoverIndexContext) === props.index\n    }));\n  }), name);\n  WithHovering.displayName = `WithHovering(${name})`;\n  return WithHovering;\n};\n\nconst useActiveState = (isHovering, isDisabled, ...moreKeys) => {\n  const [active, setActive] = useState(false);\n  const activeKeys = [Keys.SPACE, Keys.ENTER, ...moreKeys];\n\n  const cancelActive = () => setActive(false);\n\n  return {\n    isActive: active,\n    onPointerDown: () => {\n      if (!isDisabled) setActive(true);\n    },\n    onPointerUp: cancelActive,\n    onPointerLeave: cancelActive,\n    onKeyDown: e => {\n      if (isHovering && !isDisabled && activeKeys.includes(e.key)) {\n        setActive(true);\n      }\n    },\n    onKeyUp: e => {\n      if (activeKeys.includes(e.key)) {\n        setActive(false);\n      }\n    },\n    onBlur: e => {\n      if (!e.currentTarget.contains(e.relatedTarget)) {\n        setActive(false);\n      }\n    }\n  };\n};\n\nconst useBEM = ({\n  block,\n  element,\n  modifiers,\n  className\n}) => useMemo(() => {\n  const blockElement = element ? `${block}__${element}` : block;\n  let classString = blockElement;\n\n  for (const name of Object.keys(modifiers || {})) {\n    const value = modifiers[name];\n\n    if (value) {\n      classString += ` ${blockElement}--`;\n      classString += value === true ? name : `${name}-${value}`;\n    }\n  }\n\n  let expandedClassName = typeof className === 'function' ? className(modifiers) : className;\n\n  if (typeof expandedClassName === 'string') {\n    expandedClassName = expandedClassName.trim();\n    if (expandedClassName) classString += ` ${expandedClassName}`;\n  }\n\n  return classString;\n}, [block, element, modifiers, className]);\n\nconst setRef = (ref, element) => {\n  if (typeof ref === 'function') {\n    ref(element);\n  } else if (ref) {\n    ref.current = element;\n  }\n};\n\nconst useCombinedRef = (refA, refB) => useMemo(() => {\n  if (!refA) return refB;\n  if (!refB) return refA;\n  return element => {\n    setRef(refA, element);\n    setRef(refB, element);\n  };\n}, [refA, refB]);\n\nconst isObject = obj => obj && typeof obj === 'object';\n\nconst sanitiseKey = key => key.charAt(0) === '$' ? key.slice(1) : key;\n\nconst useFlatStyles = (styles, modifiers) => useMemo(() => {\n  if (typeof styles === 'function') return styles(modifiers);\n  if (!isObject(styles)) return undefined;\n  if (!modifiers) return styles;\n  const style = {};\n\n  for (const prop of Object.keys(styles)) {\n    const value = styles[prop];\n\n    if (isObject(value)) {\n      const modifierValue = modifiers[sanitiseKey(prop)];\n\n      if (typeof modifierValue === 'string') {\n        for (const nestedProp of Object.keys(value)) {\n          const nestedValue = value[nestedProp];\n\n          if (isObject(nestedValue)) {\n            if (sanitiseKey(nestedProp) === modifierValue) {\n              Object.assign(style, nestedValue);\n            }\n          } else {\n            style[nestedProp] = nestedValue;\n          }\n        }\n      } else if (modifierValue) {\n        Object.assign(style, value);\n      }\n    } else {\n      style[prop] = value;\n    }\n  }\n\n  return style;\n}, [styles, modifiers]);\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nconst useItemState = (ref, index, isHovering, isDisabled) => {\n  const {\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const timeoutId = useRef();\n\n  const setHover = () => {\n    if (!isDisabled) dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n  };\n\n  const onBlur = e => {\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const onMouseEnter = () => {\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(setHover, submenuCloseDelay);\n    } else {\n      setHover();\n    }\n  };\n\n  const onMouseLeave = (_, keepHover) => {\n    timeoutId.current && clearTimeout(timeoutId.current);\n    if (!keepHover) dispatch({\n      type: HoverIndexActionTypes.UNSET,\n      index\n    });\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      ref.current && ref.current.focus();\n    }\n  }, [ref, isHovering, isParentOpen]);\n  return {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  };\n};\n\nconst useMenuChange = (onMenuChange, isOpen) => {\n  const prevOpen = useRef(isOpen);\n  useEffect(() => {\n    if (prevOpen.current !== isOpen) safeCall(onMenuChange, {\n      open: isOpen\n    });\n    prevOpen.current = isOpen;\n  }, [onMenuChange, isOpen]);\n};\n\nconst useMenuState = ({\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout\n} = {}) => {\n  const [state, toggleMenu, endTransition] = useTransition({\n    mountOnEnter: !initialMounted,\n    unmountOnExit: unmountOnClose,\n    timeout: transitionTimeout,\n    enter: getTransition(transition, 'open'),\n    exit: getTransition(transition, 'close')\n  });\n  return {\n    state: MenuStateMap[state],\n    toggleMenu,\n    endTransition\n  };\n};\n\nconst useMenuStateAndFocus = options => {\n  const menuState = useMenuState(options);\n  const [menuItemFocus, setMenuItemFocus] = useState({\n    position: FocusPositions.INITIAL\n  });\n\n  const openMenu = (position = FocusPositions.INITIAL) => {\n    setMenuItemFocus({\n      position\n    });\n    menuState.toggleMenu(true);\n  };\n\n  return { ...menuState,\n    openMenu,\n    menuItemFocus\n  };\n};\n\nconst MenuButton = defineName( /*#__PURE__*/forwardRef(function MenuButton({\n  className,\n  styles,\n  isOpen,\n  disabled,\n  children,\n  ...restProps\n}, ref) {\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen\n  }), [isOpen]);\n  return /*#__PURE__*/React.createElement(\"button\", Object.assign({\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": disabled || undefined,\n    disabled: disabled\n  }, restProps, {\n    ref: ref,\n    className: useBEM({\n      block: menuButtonClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), children);\n}), 'MenuButton');\nMenuButton.propTypes = { ...stylePropTypes(),\n  isOpen: PropTypes.bool,\n  disabled: PropTypes.bool,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func,\n  onKeyDown: PropTypes.func\n};\n\nconst getPositionHelpers = ({\n  menuRef,\n  containerRef,\n  scrollingRef,\n  boundingBoxPadding\n}) => {\n  const menuRect = menuRef.current.getBoundingClientRect();\n  const containerRect = containerRef.current.getBoundingClientRect();\n  const boundingRect = scrollingRef.current === window ? {\n    left: 0,\n    top: 0,\n    right: document.documentElement.clientWidth,\n    bottom: window.innerHeight\n  } : scrollingRef.current.getBoundingClientRect();\n  const padding = parsePadding(boundingBoxPadding);\n\n  const getLeftOverflow = x => x + containerRect.left - boundingRect.left - padding.left;\n\n  const getRightOverflow = x => x + containerRect.left + menuRect.width - boundingRect.right + padding.right;\n\n  const getTopOverflow = y => y + containerRect.top - boundingRect.top - padding.top;\n\n  const getBottomOverflow = y => y + containerRect.top + menuRect.height - boundingRect.bottom + padding.bottom;\n\n  const confineHorizontally = x => {\n    let leftOverflow = getLeftOverflow(x);\n\n    if (leftOverflow < 0) {\n      x -= leftOverflow;\n    } else {\n      const rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        x -= rightOverflow;\n        leftOverflow = getLeftOverflow(x);\n        if (leftOverflow < 0) x -= leftOverflow;\n      }\n    }\n\n    return x;\n  };\n\n  const confineVertically = y => {\n    let topOverflow = getTopOverflow(y);\n\n    if (topOverflow < 0) {\n      y -= topOverflow;\n    } else {\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        y -= bottomOverflow;\n        topOverflow = getTopOverflow(y);\n        if (topOverflow < 0) y -= topOverflow;\n      }\n    }\n\n    return y;\n  };\n\n  return {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  };\n};\n\nconst positionContextMenu = ({\n  positionHelpers,\n  anchorPoint\n}) => {\n  const {\n    menuRect,\n    containerRect,\n    getLeftOverflow,\n    getRightOverflow,\n    getTopOverflow,\n    getBottomOverflow,\n    confineHorizontally,\n    confineVertically\n  } = positionHelpers;\n  let x, y;\n  x = anchorPoint.x - containerRect.left;\n  y = anchorPoint.y - containerRect.top;\n  const rightOverflow = getRightOverflow(x);\n\n  if (rightOverflow > 0) {\n    const adjustedX = x - menuRect.width;\n    const leftOverflow = getLeftOverflow(adjustedX);\n\n    if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n      x = adjustedX;\n    }\n\n    x = confineHorizontally(x);\n  }\n\n  let computedDirection = 'bottom';\n  const bottomOverflow = getBottomOverflow(y);\n\n  if (bottomOverflow > 0) {\n    const adjustedY = y - menuRect.height;\n    const topOverflow = getTopOverflow(adjustedY);\n\n    if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n      y = adjustedY;\n      computedDirection = 'top';\n    }\n\n    y = confineVertically(y);\n  }\n\n  return {\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowVertical = ({\n  arrowRef,\n  menuY,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let y = anchorRect.top - containerRect.top - menuY + anchorRect.height / 2;\n  const offset = arrowRef.current.offsetHeight * 1.25;\n  y = Math.max(offset, y);\n  y = Math.min(y, menuRect.height - offset);\n  return y;\n};\n\nconst placeLeftorRight = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeLeftorRightY,\n  placeLeftX,\n  placeRightX,\n  getLeftOverflow,\n  getRightOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction;\n  let y = placeLeftorRightY;\n\n  if (position !== 'initial') {\n    y = confineVertically(y);\n\n    if (position === 'anchor') {\n      y = Math.min(y, anchorRect.bottom - containerRect.top);\n      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);\n    }\n  }\n\n  let x, leftOverflow, rightOverflow;\n\n  if (computedDirection === 'left') {\n    x = placeLeftX;\n\n    if (position !== 'initial') {\n      leftOverflow = getLeftOverflow(x);\n\n      if (leftOverflow < 0) {\n        rightOverflow = getRightOverflow(placeRightX);\n\n        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {\n          x = placeRightX;\n          computedDirection = 'right';\n        }\n      }\n    }\n  } else {\n    x = placeRightX;\n\n    if (position !== 'initial') {\n      rightOverflow = getRightOverflow(x);\n\n      if (rightOverflow > 0) {\n        leftOverflow = getLeftOverflow(placeLeftX);\n\n        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n          x = placeLeftX;\n          computedDirection = 'left';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') x = confineHorizontally(x);\n  const arrowY = arrow ? placeArrowVertical({\n    menuY: y,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowY,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst placeArrowHorizontal = ({\n  arrowRef,\n  menuX,\n  anchorRect,\n  containerRect,\n  menuRect\n}) => {\n  let x = anchorRect.left - containerRect.left - menuX + anchorRect.width / 2;\n  const offset = arrowRef.current.offsetWidth * 1.25;\n  x = Math.max(offset, x);\n  x = Math.min(x, menuRect.width - offset);\n  return x;\n};\n\nconst placeToporBottom = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeToporBottomX,\n  placeTopY,\n  placeBottomY,\n  getTopOverflow,\n  getBottomOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction === 'top' ? 'top' : 'bottom';\n  let x = placeToporBottomX;\n\n  if (position !== 'initial') {\n    x = confineHorizontally(x);\n\n    if (position === 'anchor') {\n      x = Math.min(x, anchorRect.right - containerRect.left);\n      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);\n    }\n  }\n\n  let y, topOverflow, bottomOverflow;\n\n  if (computedDirection === 'top') {\n    y = placeTopY;\n\n    if (position !== 'initial') {\n      topOverflow = getTopOverflow(y);\n\n      if (topOverflow < 0) {\n        bottomOverflow = getBottomOverflow(placeBottomY);\n\n        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {\n          y = placeBottomY;\n          computedDirection = 'bottom';\n        }\n      }\n    }\n  } else {\n    y = placeBottomY;\n\n    if (position !== 'initial') {\n      bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0) {\n        topOverflow = getTopOverflow(placeTopY);\n\n        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n          y = placeTopY;\n          computedDirection = 'top';\n        }\n      }\n    }\n  }\n\n  if (position === 'auto') y = confineVertically(y);\n  const arrowX = arrow ? placeArrowHorizontal({\n    menuX: x,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowX,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nconst positionMenu = ({\n  arrow,\n  align,\n  direction,\n  offsetX,\n  offsetY,\n  position,\n  anchorRef,\n  arrowRef,\n  positionHelpers\n}) => {\n  const {\n    menuRect,\n    containerRect\n  } = positionHelpers;\n  let horizontalOffset = offsetX;\n  let verticalOffset = offsetY;\n\n  if (arrow) {\n    if (direction === 'left' || direction === 'right') {\n      horizontalOffset += arrowRef.current.offsetWidth;\n    } else {\n      verticalOffset += arrowRef.current.offsetHeight;\n    }\n  }\n\n  const anchorRect = anchorRef.current.getBoundingClientRect();\n  const placeLeftX = anchorRect.left - containerRect.left - menuRect.width - horizontalOffset;\n  const placeRightX = anchorRect.right - containerRect.left + horizontalOffset;\n  const placeTopY = anchorRect.top - containerRect.top - menuRect.height - verticalOffset;\n  const placeBottomY = anchorRect.bottom - containerRect.top + verticalOffset;\n  let placeToporBottomX, placeLeftorRightY;\n\n  if (align === 'end') {\n    placeToporBottomX = anchorRect.right - containerRect.left - menuRect.width;\n    placeLeftorRightY = anchorRect.bottom - containerRect.top - menuRect.height;\n  } else if (align === 'center') {\n    placeToporBottomX = anchorRect.left - containerRect.left - (menuRect.width - anchorRect.width) / 2;\n    placeLeftorRightY = anchorRect.top - containerRect.top - (menuRect.height - anchorRect.height) / 2;\n  } else {\n    placeToporBottomX = anchorRect.left - containerRect.left;\n    placeLeftorRightY = anchorRect.top - containerRect.top;\n  }\n\n  placeToporBottomX += horizontalOffset;\n  placeLeftorRightY += verticalOffset;\n  const options = { ...positionHelpers,\n    anchorRect,\n    placeLeftX,\n    placeRightX,\n    placeLeftorRightY,\n    placeTopY,\n    placeBottomY,\n    placeToporBottomX,\n    arrowRef,\n    arrow,\n    direction,\n    position\n  };\n\n  switch (direction) {\n    case 'left':\n    case 'right':\n      return placeLeftorRight(options);\n\n    case 'top':\n    case 'bottom':\n    default:\n      return placeToporBottom(options);\n  }\n};\n\nconst MenuList = ({\n  ariaLabel,\n  menuClassName,\n  menuStyles,\n  arrowClassName,\n  arrowStyles,\n  anchorPoint,\n  anchorRef,\n  containerRef,\n  externalRef,\n  parentScrollingRef,\n  arrow,\n  align,\n  direction,\n  position,\n  overflow,\n  repositionFlag,\n  captureFocus: _captureFocus = true,\n  state: menuState,\n  endTransition,\n  isDisabled,\n  menuItemFocus,\n  offsetX,\n  offsetY,\n  children,\n  onClose,\n  ...restProps\n}) => {\n  const isOpen = isMenuOpen(menuState);\n  const [menuPosition, setMenuPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [arrowPosition, setArrowPosition] = useState({});\n  const [overflowData, setOverflowData] = useState();\n  const [expandedDirection, setExpandedDirection] = useState(direction);\n  const {\n    transition,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef,\n    rootAnchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  } = useContext(SettingsContext);\n  const menuRef = useRef(null);\n  const arrowRef = useRef(null);\n  const menuItemsCount = useRef(0);\n  const prevOpen = useRef(isOpen);\n  const latestMenuSize = useRef({\n    width: 0,\n    height: 0\n  });\n  const latestHandlePosition = useRef(() => {});\n  const descendOverflowRef = useRef(false);\n  const reposFlag = useContext(MenuListContext).reposSubmenu || repositionFlag;\n  const [reposSubmenu, forceReposSubmenu] = useReducer(c => c + 1, 1);\n  const [{\n    hoverIndex,\n    openSubmenuCount\n  }, dispatch] = useReducer(reducer, {\n    hoverIndex: initialHoverIndex,\n    openSubmenuCount: 0\n  });\n  const openTransition = getTransition(transition, 'open');\n  const closeTransition = getTransition(transition, 'close');\n\n  function reducer({\n    hoverIndex,\n    openSubmenuCount\n  }, action) {\n    return {\n      hoverIndex: hoverIndexReducer(hoverIndex, action),\n      openSubmenuCount: submenuCountReducer(openSubmenuCount, action)\n    };\n  }\n\n  function hoverIndexReducer(state, {\n    type,\n    index\n  }) {\n    switch (type) {\n      case HoverIndexActionTypes.RESET:\n        return initialHoverIndex;\n\n      case HoverIndexActionTypes.SET:\n        return index;\n\n      case HoverIndexActionTypes.UNSET:\n        return state === index ? initialHoverIndex : state;\n\n      case HoverIndexActionTypes.DECREASE:\n        {\n          let i = state;\n          i--;\n          if (i < 0) i = menuItemsCount.current - 1;\n          return i;\n        }\n\n      case HoverIndexActionTypes.INCREASE:\n        {\n          let i = state;\n          i++;\n          if (i >= menuItemsCount.current) i = 0;\n          return i;\n        }\n\n      case HoverIndexActionTypes.FIRST:\n        return menuItemsCount.current > 0 ? 0 : initialHoverIndex;\n\n      case HoverIndexActionTypes.LAST:\n        return menuItemsCount.current > 0 ? menuItemsCount.current - 1 : initialHoverIndex;\n\n      default:\n        return state;\n    }\n  }\n\n  const menuItems = useMemo(() => {\n    const {\n      items,\n      endIndex,\n      descendOverflow\n    } = cloneChildren(children);\n    menuItemsCount.current = endIndex;\n    descendOverflowRef.current = descendOverflow;\n    return items;\n  }, [children]);\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.HOME:\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n        handled = true;\n        break;\n\n      case Keys.END:\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n        handled = true;\n        break;\n\n      case Keys.UP:\n        dispatch({\n          type: HoverIndexActionTypes.DECREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        dispatch({\n          type: HoverIndexActionTypes.INCREASE\n        });\n        handled = true;\n        break;\n\n      case Keys.SPACE:\n        if (e.target && e.target.className.includes(menuClass)) {\n          e.preventDefault();\n        }\n\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleAnimationEnd = () => {\n    if (menuState === 'closing') {\n      setOverflowData();\n    }\n\n    safeCall(endTransition);\n  };\n\n  const handlePosition = useCallback(() => {\n    if (!containerRef.current) {\n      if (!isProd) throw new Error('[react-menu] Menu cannot be positioned properly as container ref is null. If you initialise isOpen prop to true for ControlledMenu, please see this link for a solution: https://github.com/szhsin/react-menu/issues/2#issuecomment-719166062');\n      return;\n    }\n\n    if (!scrollingRef.current) {\n      scrollingRef.current = boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current);\n    }\n\n    const positionHelpers = getPositionHelpers({\n      menuRef,\n      containerRef,\n      scrollingRef,\n      boundingBoxPadding\n    });\n    const {\n      menuRect\n    } = positionHelpers;\n    let results = {\n      computedDirection: 'bottom'\n    };\n\n    if (anchorPoint) {\n      results = positionContextMenu({\n        positionHelpers,\n        anchorPoint\n      });\n    } else if (anchorRef) {\n      results = positionMenu({\n        arrow,\n        align,\n        direction,\n        offsetX,\n        offsetY,\n        position,\n        anchorRef,\n        arrowRef,\n        positionHelpers\n      });\n    }\n\n    let {\n      arrowX,\n      arrowY,\n      x,\n      y,\n      computedDirection\n    } = results;\n    let menuHeight = menuRect.height;\n\n    if (overflow !== 'visible') {\n      const {\n        getTopOverflow,\n        getBottomOverflow\n      } = positionHelpers;\n      let height, overflowAmt;\n      const prevHeight = latestMenuSize.current.height;\n      const bottomOverflow = getBottomOverflow(y);\n\n      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n        height = menuHeight - bottomOverflow;\n        overflowAmt = bottomOverflow;\n      } else {\n        const topOverflow = getTopOverflow(y);\n\n        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n          height = menuHeight + topOverflow;\n          overflowAmt = 0 - topOverflow;\n          if (height >= 0) y -= topOverflow;\n        }\n      }\n\n      if (height >= 0) {\n        menuHeight = height;\n        setOverflowData({\n          height,\n          overflowAmt\n        });\n      } else {\n        setOverflowData();\n      }\n    }\n\n    if (arrow) setArrowPosition({\n      x: arrowX,\n      y: arrowY\n    });\n    setMenuPosition({\n      x,\n      y\n    });\n    setExpandedDirection(computedDirection);\n    latestMenuSize.current = {\n      width: menuRect.width,\n      height: menuHeight\n    };\n  }, [arrow, align, boundingBoxPadding, direction, offsetX, offsetY, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollingRef]);\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      handlePosition();\n      if (prevOpen.current) forceReposSubmenu();\n    }\n\n    prevOpen.current = isOpen;\n    latestHandlePosition.current = handlePosition;\n  }, [isOpen, handlePosition, reposFlag]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowData && !descendOverflowRef.current) menuRef.current.scrollTop = 0;\n  }, [overflowData]);\n  useEffect(() => {\n    if (!isOpen) return;\n\n    if (!anchorScrollingRef.current && rootAnchorRef && rootAnchorRef.current.tagName) {\n      anchorScrollingRef.current = getScrollAncestor(rootAnchorRef.current);\n    }\n\n    const scrollCurrent = scrollingRef.current;\n    const menuScroll = scrollCurrent && scrollCurrent.addEventListener ? scrollCurrent : window;\n    const anchorScroll = anchorScrollingRef.current || menuScroll;\n    let scroll = viewScroll;\n    if (anchorScroll !== menuScroll && scroll === 'initial') scroll = 'auto';\n    if (scroll === 'initial') return;\n    if (scroll === 'auto' && overflow !== 'visible') scroll = 'close';\n\n    const handleScroll = () => {\n      if (scroll === 'auto') {\n        batchedUpdates(handlePosition);\n      } else {\n        safeCall(onClose, {\n          reason: CloseReason.SCROLL\n        });\n      }\n    };\n\n    const scrollObservers = anchorScroll !== menuScroll && viewScroll !== 'initial' ? [anchorScroll, menuScroll] : [anchorScroll];\n    scrollObservers.forEach(o => o.addEventListener('scroll', handleScroll));\n    return () => scrollObservers.forEach(o => o.removeEventListener('scroll', handleScroll));\n  }, [rootAnchorRef, anchorScrollingRef, scrollingRef, isOpen, overflow, onClose, viewScroll, handlePosition]);\n  const hasOverflow = Boolean(overflowData) && overflowData.overflowAmt > 0;\n  useEffect(() => {\n    if (hasOverflow || !isOpen || !parentScrollingRef) return;\n\n    const handleScroll = () => batchedUpdates(handlePosition);\n\n    const parentScroll = parentScrollingRef.current;\n    parentScroll.addEventListener('scroll', handleScroll);\n    return () => parentScroll.removeEventListener('scroll', handleScroll);\n  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);\n  useEffect(() => {\n    if (typeof ResizeObserver !== 'function' || reposition === 'initial') return;\n    const resizeObserver = new ResizeObserver(([entry]) => {\n      const {\n        borderBoxSize,\n        target\n      } = entry;\n      let width, height;\n\n      if (borderBoxSize) {\n        const {\n          inlineSize,\n          blockSize\n        } = borderBoxSize[0] || borderBoxSize;\n        width = inlineSize;\n        height = blockSize;\n      } else {\n        const borderRect = target.getBoundingClientRect();\n        width = borderRect.width;\n        height = borderRect.height;\n      }\n\n      if (width === 0 || height === 0) return;\n      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1)) return;\n      batchedUpdates(() => {\n        latestHandlePosition.current();\n        forceReposSubmenu();\n      });\n    });\n    const observeTarget = menuRef.current;\n    resizeObserver.observe(observeTarget, {\n      box: 'border-box'\n    });\n    return () => resizeObserver.unobserve(observeTarget);\n  }, [reposition]);\n  useEffect(() => {\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.RESET\n      });\n      if (!closeTransition) setOverflowData();\n    }\n\n    const id = setTimeout(() => {\n      if (!isOpen || !menuRef.current || menuRef.current.contains(document.activeElement)) return;\n      if (_captureFocus) menuRef.current.focus();\n\n      if (menuItemFocus.position === FocusPositions.FIRST) {\n        dispatch({\n          type: HoverIndexActionTypes.FIRST\n        });\n      } else if (menuItemFocus.position === FocusPositions.LAST) {\n        dispatch({\n          type: HoverIndexActionTypes.LAST\n        });\n      }\n    }, openTransition ? 170 : 100);\n    return () => clearTimeout(id);\n  }, [openTransition, closeTransition, _captureFocus, isOpen, menuItemFocus]);\n  const isSubmenuOpen = openSubmenuCount > 0;\n  const itemContext = useMemo(() => ({\n    parentMenuRef: menuRef,\n    parentOverflow: overflow,\n    isParentOpen: isOpen,\n    isSubmenuOpen,\n    dispatch\n  }), [isOpen, isSubmenuOpen, overflow]);\n  let maxHeight, overflowAmt;\n\n  if (overflowData) {\n    descendOverflowRef.current ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;\n  }\n\n  const listContext = useMemo(() => ({\n    reposSubmenu,\n    overflow,\n    overflowAmt\n  }), [reposSubmenu, overflow, overflowAmt]);\n  const overflowStyles = maxHeight >= 0 ? {\n    maxHeight,\n    overflow\n  } : undefined;\n  const modifiers = useMemo(() => ({\n    state: menuState,\n    dir: expandedDirection\n  }), [menuState, expandedDirection]);\n  const arrowModifiers = useMemo(() => Object.freeze({\n    dir: expandedDirection\n  }), [expandedDirection]);\n\n  const _arrowClass = useBEM({\n    block: menuClass,\n    element: menuArrowClass,\n    modifiers: arrowModifiers,\n    className: arrowClassName\n  });\n\n  const _arrowStyles = useFlatStyles(arrowStyles, arrowModifiers);\n\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onAnimationEnd: handleAnimationEnd\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"menu\",\n    tabIndex: \"-1\",\n    \"aria-disabled\": isDisabled || undefined,\n    \"aria-label\": ariaLabel\n  }, restProps, handlers, {\n    ref: useCombinedRef(externalRef, menuRef),\n    className: useBEM({\n      block: menuClass,\n      modifiers,\n      className: menuClassName\n    }),\n    style: { ...useFlatStyles(menuStyles, modifiers),\n      ...overflowStyles,\n      left: `${menuPosition.x}px`,\n      top: `${menuPosition.y}px`\n    }\n  }), arrow && /*#__PURE__*/React.createElement(\"div\", {\n    className: _arrowClass,\n    style: { ..._arrowStyles,\n      left: arrowPosition.x && `${arrowPosition.x}px`,\n      top: arrowPosition.y && `${arrowPosition.y}px`\n    },\n    ref: arrowRef\n  }), /*#__PURE__*/React.createElement(MenuListContext.Provider, {\n    value: listContext\n  }, /*#__PURE__*/React.createElement(MenuListItemContext.Provider, {\n    value: itemContext\n  }, /*#__PURE__*/React.createElement(HoverIndexContext.Provider, {\n    value: hoverIndex\n  }, menuItems))));\n};\n\nfunction submenuCountReducer(state, {\n  type\n}) {\n  switch (type) {\n    case SubmenuActionTypes.OPEN:\n      return state + 1;\n\n    case SubmenuActionTypes.CLOSE:\n      return Math.max(state - 1, 0);\n\n    default:\n      return state;\n  }\n}\n\nconst ControlledMenu = /*#__PURE__*/forwardRef(function ControlledMenu({\n  'aria-label': ariaLabel,\n  className,\n  containerProps,\n  initialMounted,\n  unmountOnClose,\n  transition,\n  transitionTimeout,\n  boundingBoxRef,\n  boundingBoxPadding,\n  reposition,\n  submenuOpenDelay,\n  submenuCloseDelay,\n  skipOpen,\n  viewScroll,\n  portal,\n  theming,\n  onItemClick,\n  onClose,\n  ...restProps\n}, externalRef) {\n  const containerRef = useRef(null);\n  const scrollingRef = useRef(null);\n  const anchorScrollingRef = useRef(null);\n  const {\n    anchorRef,\n    state\n  } = restProps;\n  const settings = useMemo(() => ({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef: containerRef,\n    rootAnchorRef: anchorRef,\n    scrollingRef,\n    anchorScrollingRef,\n    reposition,\n    viewScroll\n  }), [initialMounted, unmountOnClose, transition, transitionTimeout, anchorRef, boundingBoxRef, boundingBoxPadding, reposition, viewScroll]);\n  const itemSettings = useMemo(() => ({\n    submenuOpenDelay,\n    submenuCloseDelay\n  }), [submenuOpenDelay, submenuCloseDelay]);\n  const eventHandlers = useMemo(() => ({\n    handleClick(event, isCheckorRadio) {\n      if (!event.stopPropagation) safeCall(onItemClick, event);\n      let keepOpen = event.keepOpen;\n\n      if (keepOpen === undefined) {\n        keepOpen = isCheckorRadio && event.key === Keys.SPACE;\n      }\n\n      if (!keepOpen) {\n        safeCall(onClose, {\n          value: event.value,\n          key: event.key,\n          reason: CloseReason.CLICK\n        });\n      }\n    },\n\n    handleClose(key) {\n      safeCall(onClose, {\n        key,\n        reason: CloseReason.CLICK\n      });\n    }\n\n  }), [onItemClick, onClose]);\n\n  const handleKeyDown = ({\n    key\n  }) => {\n    switch (key) {\n      case Keys.ESC:\n        safeCall(onClose, {\n          key,\n          reason: CloseReason.CANCEL\n        });\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    if (isMenuOpen(state) && !e.currentTarget.contains(e.relatedTarget || document.activeElement)) {\n      safeCall(onClose, {\n        reason: CloseReason.BLUR\n      });\n\n      if (skipOpen) {\n        skipOpen.current = true;\n        setTimeout(() => skipOpen.current = false, 300);\n      }\n    }\n  };\n\n  const itemTransition = getTransition(transition, 'item');\n  const modifiers = useMemo(() => ({\n    theme: theming,\n    itemTransition\n  }), [theming, itemTransition]);\n  const handlers = attachHandlerProps({\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur\n  }, containerProps);\n  const menuList = /*#__PURE__*/React.createElement(\"div\", Object.assign({}, containerProps, handlers, {\n    className: useBEM({\n      block: menuContainerClass,\n      modifiers,\n      className\n    }),\n    ref: containerRef\n  }), state && /*#__PURE__*/React.createElement(SettingsContext.Provider, {\n    value: settings\n  }, /*#__PURE__*/React.createElement(ItemSettingsContext.Provider, {\n    value: itemSettings\n  }, /*#__PURE__*/React.createElement(EventHandlersContext.Provider, {\n    value: eventHandlers\n  }, /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, {\n    ariaLabel: ariaLabel || 'Menu',\n    externalRef: externalRef,\n    containerRef: containerRef,\n    onClose: onClose\n  }))))));\n\n  if (portal) {\n    return /*#__PURE__*/ReactDOM.createPortal(menuList, document.body);\n  } else {\n    return menuList;\n  }\n});\nControlledMenu.propTypes = { ...menuPropTypesBase,\n  state: PropTypes.oneOf(values(MenuStateMap)),\n  anchorPoint: PropTypes.exact({\n    x: PropTypes.number,\n    y: PropTypes.number\n  }),\n  anchorRef: PropTypes.object,\n  skipOpen: PropTypes.object,\n  captureFocus: PropTypes.bool,\n  menuItemFocus: PropTypes.exact({\n    position: PropTypes.string\n  }),\n  onClose: PropTypes.func\n};\nControlledMenu.defaultProps = { ...menuDefaultPropsBase,\n  menuItemFocus: {\n    position: FocusPositions.INITIAL\n  }\n};\n\nconst Menu = /*#__PURE__*/forwardRef(function Menu({\n  'aria-label': ariaLabel,\n  captureFocus: _,\n  menuButton,\n  onMenuChange,\n  ...restProps\n}, externalRef) {\n  const {\n    openMenu,\n    toggleMenu,\n    ...stateProps\n  } = useMenuStateAndFocus(restProps);\n  const isOpen = isMenuOpen(stateProps.state);\n  const skipOpen = useRef(false);\n  const buttonRef = useRef(null);\n  const handleClose = useCallback(e => {\n    toggleMenu(false);\n    if (e.key) buttonRef.current.focus();\n  }, [toggleMenu]);\n\n  const handleClick = e => {\n    if (skipOpen.current) return;\n    openMenu(e.detail === 0 ? FocusPositions.FIRST : FocusPositions.INITIAL);\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.UP:\n        openMenu(FocusPositions.LAST);\n        handled = true;\n        break;\n\n      case Keys.DOWN:\n        openMenu(FocusPositions.FIRST);\n        handled = true;\n        break;\n    }\n\n    if (handled) e.preventDefault();\n  };\n\n  const button = safeCall(menuButton, {\n    open: isOpen\n  });\n  if (!button) throw new Error('Menu requires a menuButton prop.');\n  const buttonProps = {\n    ref: useCombinedRef(button.ref, buttonRef),\n    ...attachHandlerProps({\n      onClick: handleClick,\n      onKeyDown: handleKeyDown\n    }, button.props)\n  };\n\n  if (getName(button.type) === 'MenuButton') {\n    buttonProps.isOpen = isOpen;\n  }\n\n  const renderButton = /*#__PURE__*/React.cloneElement(button, buttonProps);\n  useMenuChange(onMenuChange, isOpen);\n  const menuProps = { ...restProps,\n    ...stateProps,\n    'aria-label': ariaLabel || (typeof button.props.children === 'string' ? button.props.children : 'Menu'),\n    anchorRef: buttonRef,\n    ref: externalRef,\n    onClose: handleClose,\n    skipOpen\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, renderButton, /*#__PURE__*/React.createElement(ControlledMenu, menuProps));\n});\nMenu.propTypes = { ...menuPropTypesBase,\n  menuButton: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,\n  onMenuChange: PropTypes.func\n};\nMenu.defaultProps = menuDefaultPropsBase;\n\nconst SubMenu = withHovering( /*#__PURE__*/memo(function SubMenu({\n  'aria-label': ariaLabel,\n  className,\n  disabled,\n  label,\n  index,\n  onMenuChange,\n  isHovering,\n  captureFocus: _1,\n  repositionFlag: _2,\n  itemProps = {},\n  ...restProps\n}) {\n  const {\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout,\n    rootMenuRef\n  } = useContext(SettingsContext);\n  const {\n    submenuOpenDelay,\n    submenuCloseDelay\n  } = useContext(ItemSettingsContext);\n  const {\n    parentMenuRef,\n    parentOverflow,\n    isParentOpen,\n    isSubmenuOpen,\n    dispatch\n  } = useContext(MenuListItemContext);\n  const isPortal = parentOverflow !== 'visible';\n  const {\n    openMenu,\n    toggleMenu,\n    state,\n    ...otherStateProps\n  } = useMenuStateAndFocus({\n    initialMounted,\n    unmountOnClose,\n    transition,\n    transitionTimeout\n  });\n  const isOpen = isMenuOpen(state);\n  const isDisabled = Boolean(disabled);\n  const {\n    isActive,\n    onKeyUp,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled, Keys.RIGHT);\n  const containerRef = useRef(null);\n  const itemRef = useRef(null);\n  const timeoutId = useRef();\n\n  const delayOpen = delay => {\n    dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    });\n    timeoutId.current = setTimeout(openMenu, Math.max(delay, 0));\n  };\n\n  const handleMouseEnter = () => {\n    if (isDisabled || isOpen) return;\n\n    if (isSubmenuOpen) {\n      timeoutId.current = setTimeout(() => delayOpen(submenuOpenDelay - submenuCloseDelay), submenuCloseDelay);\n    } else {\n      delayOpen(submenuOpenDelay);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    clearTimeout(timeoutId.current);\n\n    if (!isOpen) {\n      dispatch({\n        type: HoverIndexActionTypes.UNSET,\n        index\n      });\n    }\n  };\n\n  const handleClick = () => {\n    if (isDisabled) return;\n    clearTimeout(timeoutId.current);\n    openMenu();\n  };\n\n  const handleKeyDown = e => {\n    let handled = false;\n\n    switch (e.key) {\n      case Keys.LEFT:\n        if (isOpen) {\n          toggleMenu(false);\n          itemRef.current.focus();\n          handled = true;\n        }\n\n        break;\n\n      case Keys.RIGHT:\n        if (!isOpen) handled = true;\n        break;\n    }\n\n    if (handled) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.SPACE:\n      case Keys.ENTER:\n      case Keys.RIGHT:\n        openMenu(FocusPositions.FIRST);\n        break;\n    }\n  };\n\n  useEffect(() => () => clearTimeout(timeoutId.current), []);\n  useEffect(() => {\n    if (isHovering && isParentOpen) {\n      itemRef.current.focus();\n    } else {\n      toggleMenu(false);\n    }\n  }, [isHovering, isParentOpen, toggleMenu]);\n  useEffect(() => {\n    dispatch({\n      type: isOpen ? SubmenuActionTypes.OPEN : SubmenuActionTypes.CLOSE\n    });\n  }, [dispatch, isOpen]);\n  useMenuChange(onMenuChange, isOpen);\n  const modifiers = useMemo(() => Object.freeze({\n    open: isOpen,\n    hover: isHovering,\n    active: isActive,\n    disabled: isDisabled\n  }), [isOpen, isHovering, isActive, isDisabled]);\n  const {\n    ref: externaItemlRef,\n    className: itemClassName,\n    styles: itemStyles,\n    ...restItemProps\n  } = itemProps;\n  const itemHandlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onMouseDown: () => !isHovering && dispatch({\n      type: HoverIndexActionTypes.SET,\n      index\n    }),\n    onClick: handleClick,\n    onKeyUp: handleKeyUp\n  }, restItemProps);\n\n  const getMenuList = () => {\n    const menuList = /*#__PURE__*/React.createElement(MenuList, Object.assign({}, restProps, otherStateProps, {\n      state: state,\n      ariaLabel: ariaLabel || (typeof label === 'string' ? label : 'Submenu'),\n      anchorRef: itemRef,\n      containerRef: isPortal ? rootMenuRef : containerRef,\n      parentScrollingRef: isPortal && parentMenuRef,\n      isDisabled: isDisabled\n    }));\n    return isPortal ? /*#__PURE__*/createPortal(menuList, rootMenuRef.current) : menuList;\n  };\n\n  return /*#__PURE__*/React.createElement(\"li\", {\n    className: useBEM({\n      block: menuClass,\n      element: subMenuClass,\n      className\n    }),\n    role: \"presentation\",\n    ref: containerRef,\n    onKeyDown: handleKeyDown\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    role: \"menuitem\",\n    \"aria-haspopup\": true,\n    \"aria-expanded\": isOpen,\n    \"aria-disabled\": isDisabled || undefined,\n    tabIndex: isHovering && !isOpen ? 0 : -1\n  }, restItemProps, itemHandlers, {\n    ref: useCombinedRef(externaItemlRef, itemRef),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className: itemClassName\n    }),\n    style: useFlatStyles(itemStyles, modifiers)\n  }), useMemo(() => safeCall(label, modifiers), [label, modifiers])), state && getMenuList());\n}), 'SubMenu');\nSubMenu.propTypes = { ...sharedMenuPropTypes,\n  disabled: PropTypes.bool,\n  label: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  itemProps: PropTypes.shape({ ...stylePropTypes()\n  }),\n  onMenuChange: PropTypes.func\n};\nSubMenu.defaultProps = { ...sharedMenuDefaultProp,\n  direction: 'right'\n};\n\nconst MenuItem = withHovering( /*#__PURE__*/memo(function MenuItem({\n  className,\n  styles,\n  value,\n  href,\n  type,\n  checked,\n  disabled,\n  index,\n  children,\n  onClick,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = Boolean(disabled);\n  const ref = useRef();\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const eventHandlers = useContext(EventHandlersContext);\n  const radioGroup = useContext(RadioGroupContext);\n  const {\n    isActive,\n    onKeyUp,\n    onBlur: activeStateBlur,\n    ...activeStateHandlers\n  } = useActiveState(isHovering, isDisabled);\n  const isRadio = type === 'radio';\n  const isCheckBox = type === 'checkbox';\n  const isAnchor = Boolean(href) && !isDisabled && !isRadio && !isCheckBox;\n  const isChecked = isRadio ? radioGroup.value === value : isCheckBox ? Boolean(checked) : false;\n\n  const handleClick = e => {\n    if (isDisabled) return;\n    const event = {\n      value,\n      syntheticEvent: e\n    };\n    if (e.key !== undefined) event.key = e.key;\n    if (isCheckBox) event.checked = !isChecked;\n\n    if (isRadio) {\n      event.name = radioGroup.name;\n      safeCall(radioGroup.onRadioChange, event);\n    }\n\n    if (!event.stopPropagation) safeCall(onClick, event);\n    eventHandlers.handleClick(event, isCheckBox || isRadio);\n  };\n\n  const handleKeyUp = e => {\n    if (!isActive) return;\n    onKeyUp(e);\n\n    switch (e.key) {\n      case Keys.SPACE:\n      case Keys.ENTER:\n        if (isAnchor) {\n          ref.current.click();\n        } else {\n          handleClick(e);\n        }\n\n        break;\n    }\n  };\n\n  const handleBlur = e => {\n    activeStateBlur(e);\n    onBlur(e);\n  };\n\n  const modifiers = useMemo(() => Object.freeze({\n    type,\n    disabled: isDisabled,\n    hover: isHovering,\n    active: isActive,\n    checked: isChecked,\n    anchor: isAnchor\n  }), [type, isDisabled, isHovering, isActive, isChecked, isAnchor]);\n  const handlers = attachHandlerProps({ ...activeStateHandlers,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown: setHover,\n    onKeyUp: handleKeyUp,\n    onBlur: handleBlur,\n    onClick: handleClick\n  }, restProps);\n  const menuItemProps = {\n    role: isRadio ? 'menuitemradio' : isCheckBox ? 'menuitemcheckbox' : 'menuitem',\n    'aria-checked': isRadio || isCheckBox ? isChecked : undefined,\n    'aria-disabled': isDisabled || undefined,\n    tabIndex: isHovering ? 0 : -1,\n    ...restProps,\n    ...handlers,\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  };\n  const renderChildren = useMemo(() => safeCall(children, modifiers), [children, modifiers]);\n\n  if (isAnchor) {\n    return /*#__PURE__*/React.createElement(\"li\", {\n      role: \"presentation\"\n    }, /*#__PURE__*/React.createElement(\"a\", Object.assign({}, menuItemProps, {\n      href: href\n    }), renderChildren));\n  } else {\n    return /*#__PURE__*/React.createElement(\"li\", menuItemProps, renderChildren);\n  }\n}), 'MenuItem');\nMenuItem.propTypes = { ...stylePropTypes(),\n  value: PropTypes.any,\n  href: PropTypes.string,\n  type: PropTypes.oneOf(['checkbox', 'radio']),\n  checked: PropTypes.bool,\n  disabled: PropTypes.bool,\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  onClick: PropTypes.func\n};\n\nconst FocusableItem = withHovering( /*#__PURE__*/memo(function FocusableItem({\n  className,\n  styles,\n  disabled,\n  index,\n  children,\n  isHovering,\n  externalRef,\n  ...restProps\n}) {\n  const isDisabled = Boolean(disabled);\n  const ref = useRef(null);\n  const {\n    setHover,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave\n  } = useItemState(ref, index, isHovering, isDisabled);\n  const {\n    handleClose\n  } = useContext(EventHandlersContext);\n  const modifiers = useMemo(() => Object.freeze({\n    disabled: isDisabled,\n    hover: isHovering,\n    focusable: true\n  }), [isDisabled, isHovering]);\n  const renderChildren = useMemo(() => safeCall(children, { ...modifiers,\n    ref,\n    closeMenu: handleClose\n  }), [children, modifiers, handleClose]);\n  const handlers = attachHandlerProps({\n    onMouseEnter,\n    onMouseLeave: e => onMouseLeave(e, true),\n    onFocus: setHover,\n    onBlur\n  }, restProps);\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    \"aria-disabled\": isDisabled || undefined,\n    role: \"menuitem\",\n    tabIndex: \"-1\"\n  }, restProps, handlers, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuItemClass,\n      modifiers,\n      className\n    }),\n    style: useFlatStyles(styles, modifiers)\n  }), renderChildren);\n}), 'FocusableItem');\nFocusableItem.propTypes = { ...stylePropTypes(),\n  disabled: PropTypes.bool,\n  children: PropTypes.func.isRequired\n};\n\nconst MenuDivider = defineName( /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuDivider({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"separator\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuDividerClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n})), 'MenuDivider');\nMenuDivider.propTypes = { ...stylePropTypes()\n};\n\nconst MenuHeader = defineName( /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function MenuHeader({\n  className,\n  styles,\n  ...restProps\n}, externalRef) {\n  return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n    role: \"presentation\"\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: menuHeaderClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }));\n})), 'MenuHeader');\nMenuHeader.propTypes = { ...stylePropTypes()\n};\n\nconst MenuGroup = defineName( /*#__PURE__*/forwardRef(function MenuGroup({\n  className,\n  styles,\n  takeOverflow,\n  ...restProps\n}, externalRef) {\n  const ref = useRef(null);\n  const [overflowStyles, setOverflowStyles] = useState();\n  const {\n    overflow,\n    overflowAmt\n  } = useContext(MenuListContext);\n  useIsomorphicLayoutEffect(() => {\n    let maxHeight;\n\n    if (takeOverflow && overflowAmt >= 0) {\n      maxHeight = ref.current.getBoundingClientRect().height - overflowAmt;\n      if (maxHeight < 0) maxHeight = 0;\n    }\n\n    setOverflowStyles(maxHeight >= 0 ? {\n      maxHeight,\n      overflow\n    } : undefined);\n  }, [takeOverflow, overflow, overflowAmt]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowStyles) ref.current.scrollTop = 0;\n  }, [overflowStyles]);\n  return /*#__PURE__*/React.createElement(\"div\", Object.assign({}, restProps, {\n    ref: useCombinedRef(externalRef, ref),\n    className: useBEM({\n      block: menuClass,\n      element: menuGroupClass,\n      className\n    }),\n    style: { ...useFlatStyles(styles),\n      ...overflowStyles\n    }\n  }));\n}), 'MenuGroup');\nMenuGroup.propTypes = { ...stylePropTypes(),\n  takeOverflow: PropTypes.bool\n};\n\nconst MenuRadioGroup = defineName( /*#__PURE__*/forwardRef(function MenuRadioGroup({\n  'aria-label': ariaLabel,\n  className,\n  styles,\n  name,\n  value,\n  children,\n  onRadioChange,\n  ...restProps\n}, externalRef) {\n  const contextValue = useMemo(() => ({\n    name,\n    value,\n    onRadioChange\n  }), [name, value, onRadioChange]);\n  return /*#__PURE__*/React.createElement(\"li\", {\n    role: \"presentation\"\n  }, /*#__PURE__*/React.createElement(\"ul\", Object.assign({\n    role: \"group\",\n    \"aria-label\": ariaLabel || name || 'Radio group'\n  }, restProps, {\n    ref: externalRef,\n    className: useBEM({\n      block: menuClass,\n      element: radioGroupClass,\n      className\n    }),\n    style: useFlatStyles(styles)\n  }), /*#__PURE__*/React.createElement(RadioGroupContext.Provider, {\n    value: contextValue\n  }, children)));\n}), 'MenuRadioGroup');\nMenuRadioGroup.propTypes = { ...stylePropTypes(),\n  name: PropTypes.string,\n  value: PropTypes.any,\n  children: PropTypes.node.isRequired,\n  onRadioChange: PropTypes.func\n};\n\nexport { ControlledMenu, FocusableItem, Menu, MenuButton, MenuDivider, MenuGroup, MenuHeader, MenuItem, MenuRadioGroup, SubMenu, applyHOC, applyStatics, useMenuState };\n"]},"metadata":{},"sourceType":"module"}